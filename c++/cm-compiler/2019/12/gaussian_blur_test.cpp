/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "cm_rt.h"

// Includes bitmap_helpers.h for bitmap file open/save operations.
#include "common/bitmap_helpers.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

using cm::util::bitmap::BitMap;

// For vertical direction.
// Defines the number of columns per thread.
#define NUM_COLS_PER_THREAD 8

// For horizontal direction.
// Defines the number of rows per thread.
#define NUM_ROWS_PER_THREAD 8

// Declares coefficients for gaussian filter.
float a0 = 0, a1 = 0, a2 = 0, a3 = 0, b1 = 0, b2 = 0, coefp = 0, coefn = 0;

// This function is used to computes coefficients for gaussian filter.
void CalculateCoefficients(float sigma, int order) {
    const float nsigma = sigma < 0.1f ? 0.1f : sigma;
    const float alpha = 1.695f / nsigma;
    const float ema = (float)exp(-alpha);
    const float ema2 = (float)exp(-2 * alpha);

    b1 = -2 * ema;
    b2 = ema2;

    switch (order) {
    case 0: {
        const float k = (1 - ema) * (1 - ema) / (1 + 2 * alpha * ema - ema2);
        a0 = k;
        a1 = k * (alpha - 1) * ema;
        a2 = k * (alpha + 1) * ema;
        a3 = -k * ema2;
    } break;

    case 1: {
        const float k = (1 - ema) * (1 - ema) / ema;
        a0 = k * ema;
        a1 = a3 = 0;
        a2 = -a0;
    } break;

    case 2: {
        const float
            ea = (float)exp(-alpha),
            k = -(ema2 - 1) / (2 * alpha * ema),
            kn = (-2 * (-1 + 3 * ea - 3 * ea * ea + ea * ea * ea) /
                       (3 * ea + 1 + 3 * ea * ea + ea * ea * ea));
        a0 = kn;
        a1 = -kn * (1 + k * alpha) * ema;
        a2 = kn * (1 - k * alpha) * ema;
        a3 = -kn * ema2;
    } break;

    default:
        fprintf(stderr, "gaussianFilter: invalid order parameter!\n");
        return;
    }
    coefp = (a0 + a1) / (1 + b1 + b2);
    coefn = (a2 + a3) / (1 + b1 + b2);
    printf("Coefficients are: \n");
    printf(" a0 = %f, a1 = %f, a2 = %f, a3 = %f, b1 = %f, b2 = %f\n", a0, a1, a2, a3, b1, b2);
}

int main(int argc, char *argv[]) {
    // Loads an input image named "lena.bmp".
    auto input_image = BitMap::load("lena.bmp");

    // Gets the width and height of the input image.
    unsigned int width = input_image.getWidth();
    unsigned int height = input_image.getHeight();
    printf("image width = %d, height = %d\n", width, height);

    // Checks the value of width, height and bpp(bits per pixel) of the image.
    // Only images in 8-bit RGB format are supported.
    // Only images with width and height a multiple of 8 are supported.
    if (width & 7 || height & 7 || input_image.getBPP() != 24) {
        std::cerr << "Error: Only images in 8-bit RGB format with width and "
                  << "height a multiple of 8 are supported.\n";
        std::exit(1);
    }

    // Copies input image to output except for the data.
    auto output_image = input_image;

    // Sets image size in bytes. There are a total of width*height pixels and
    // each pixel occupies (out.getBPP()/8) bytes.
    unsigned int img_size = width * height * output_image.getBPP() / 8;

    // Sets output to blank image.
    output_image.setData(new unsigned char[img_size]);

    // Allocates system memory for rgb_to_rgba to convert image format from
    // RGB to RGBA.
    // Allocates system memory for rgba_to_rgb to convert image format from
    // RGBA to RGB.
    unsigned int num_pixels = width * height;
    unsigned char *rgb_to_rgba = new unsigned char[num_pixels * 4];
    unsigned char *rgba_to_rgb = new unsigned char[num_pixels * 4];

    // Converts image format from RGB to RGBA.
    // Copies the RGB values from the image, set the 4th byte with zero.
    for (int i = 0; i < num_pixels; i++) {
        rgb_to_rgba[i * 4] = input_image.getData()[i * 3];
        rgb_to_rgba[i * 4 + 1] = input_image.getData()[i * 3 + 1];
        rgb_to_rgba[i * 4 + 2] = input_image.getData()[i * 3 + 2];
        rgb_to_rgba[i * 4 + 3] = 0;
    }

    // Computes coefficients for gaussian filter.
    float sigma = 10.0f;
    int order = 0;
    CalculateCoefficients(sigma, order);

    // Creates a CmDevice from scratch.
    // Param device: pointer to the CmDevice object.
    // Param version: CM API version supported by the runtime library.
    CmDevice *device = nullptr;
    unsigned int version = 0;
    cm_result_check(::CreateCmDevice(device, version));

    // The file gaussian_blur_test_genx.isa is generated when the kernels in the
    // file gaussian_blur_test_genx.cpp are compiled by the CM compiler.
    // Reads in the virtual ISA from "gaussian_blur_test_genx.isa" to the code
    // buffer.
    std::string isa_code = cm::util::isa::loadFile("gaussian_blur_test_genx.isa");
    if (isa_code.size() == 0) {
        std::cerr << "Error: empty ISA binary.\n";
        std::exit(1);
    }

    // Creates a CmProgram object consisting of the kernels loaded from the code
    // buffer.
    // Param isa_code.data(): Pointer to the code buffer containing the virtual
    // ISA.
    // Param isa_code.size(): Size in bytes of the code buffer containing the
    // virtual ISA.
    CmProgram *program = nullptr;
    cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                        isa_code.size(),
                                        program));

    // For vertical direction.

    // Creates the kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "gaussianVertical": The kernel name which should be no more than 256
    // bytes including the null terminator.
    CmKernel *kernel_vertical = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "gaussianVertical",
                                         kernel_vertical));

    // Creates input surface with given width and height in pixels and format.
    CmSurface2D *input_surface = nullptr;
    cm_result_check(device->CreateSurface2D(4 * width,
                                            height,
                                            CM_SURFACE_FORMAT_A8,
                                            input_surface));

    // Copies system memory content to the input surface using the CPU. The
    // system memory content is the data of the input image in RGBA format.
    // The size of data copied is the size of data in the rgb_to_rgba.
    cm_result_check(input_surface->WriteSurface(rgb_to_rgba, nullptr));

    // Creates the temp surface. The width, height and format is the same as
    // the input surface.
    // The temp surface contains the output of kernel_vertical.
    CmSurface2D *temp_surface = nullptr;
    cm_result_check(device->CreateSurface2D(4 * width,
                                            height,
                                            CM_SURFACE_FORMAT_A8,
                                            temp_surface));

    // When a surface is created by the CmDevice a SurfaceIndex object is
    // created. This object contains a unique index value that is mapped to the
    // surface.
    // Gets the input surface index.
    SurfaceIndex *input_surface_idx = nullptr;
    cm_result_check(input_surface->GetIndex(input_surface_idx));

    // Gets the temp surface index.
    SurfaceIndex *temp_surface_idx = nullptr;
    cm_result_check(temp_surface->GetIndex(temp_surface_idx));

    // Sets a per kernel argument.
    // Sets input surface index as the first argument of kernel_vertical.
    // Sets temp surface index as the second argument of kernel_vertical.
    cm_result_check(kernel_vertical->SetKernelArg(0,
                                                  sizeof(SurfaceIndex),
                                                  input_surface_idx));
    cm_result_check(kernel_vertical->SetKernelArg(1,
                                                  sizeof(SurfaceIndex),
                                                  temp_surface_idx));

    // Sets the image width and height as the third and the fourth argument
    // of kernel_vertical.
    cm_result_check(kernel_vertical->SetKernelArg(2, 4, &width));
    cm_result_check(kernel_vertical->SetKernelArg(3, 4, &height));

    // Sets filter coefficients as the rest arguments of kernel_vertical.
    cm_result_check(kernel_vertical->SetKernelArg(4, 4, &a0));
    cm_result_check(kernel_vertical->SetKernelArg(5, 4, &a1));
    cm_result_check(kernel_vertical->SetKernelArg(6, 4, &a2));
    cm_result_check(kernel_vertical->SetKernelArg(7, 4, &a3));
    cm_result_check(kernel_vertical->SetKernelArg(8, 4, &b1));
    cm_result_check(kernel_vertical->SetKernelArg(9, 4, &b2));
    cm_result_check(kernel_vertical->SetKernelArg(10, 4, &coefp));
    cm_result_check(kernel_vertical->SetKernelArg(11, 4, &coefn));

    // Each CmKernel can be executed by multiple concurrent threads.
    // Here, for "kernel_vertical" kernel, each thread works on
    // NUM_COLS_PER_THREAD columns in vertical direction.
    int thread_width = width / NUM_COLS_PER_THREAD;

    // Creates a CmThreadSpace object.
    // There are two usage models for the thread space. One is to define the
    // dependency between threads to run in the GPU. The other is to define a
    // thread space where each thread can get a pair of coordinates during
    // kernel execution. For this example, we use the latter usage model.
    CmThreadSpace *thread_space = nullptr;
    cm_result_check(device->CreateThreadSpace(thread_width,
                                              1,
                                              thread_space));

    // Creates a task queue.
    // The CmQueue is an in-order queue. Tasks get executed according to the
    // order they are enqueued. The next task does not start execution until the
    // current task finishes.
    CmQueue *cmd_queue = nullptr;
    cm_result_check(device->CreateQueue(cmd_queue));

    // Creates a CmTask object.
    // The CmTask object is a container for CmKernel pointers. It is used to
    // enqueue the kernels for execution.
    CmTask *task = nullptr;
    cm_result_check(device->CreateTask(task));

    // Adds a CmKernel pointer to CmTask.
    // This task has one kernel.
    cm_result_check(task->AddKernel(kernel_vertical));

    // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
    // function returns immediately without waiting for the GPU to start or
    // finish execution of the task. The runtime will query the HW status. If
    // the hardware is not busy, the runtime will submit the task to the
    // driver/HW; otherwise, the runtime will submit the task to the driver/HW
    // at another time.
    // An event, "sync_event", is created to track the status of the task.
    CmEvent *sync_event = nullptr;
    cm_result_check(cmd_queue->Enqueue(task,
                                       sync_event,
                                       thread_space));

    // Destroys a CmTask object.
    // CmTask will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmTask object by itself.
    cm_result_check(device->DestroyTask(task));

    // For horizontal direction.

    // Creates the kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "gaussianHorizontal": The kernel name which should be no more than
    // 256 bytes including the null terminator.
    CmKernel *kernel_horizontal = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "gaussianHorizontal",
                                         kernel_horizontal));

    // Creates the output surface. The width, height and format is the same as
    // the input surface.
    // The output surface contains the output of kernel_horizontal.
    CmSurface2D *output_surface = nullptr;
    cm_result_check(device->CreateSurface2D(4 * width,
                                            height,
                                            CM_SURFACE_FORMAT_A8,
                                            output_surface));

    // Gets the output surface index.
    SurfaceIndex *output_surface_idx = nullptr;
    cm_result_check(output_surface->GetIndex(output_surface_idx));

    // Sets a per kernel argument.
    // Sets the output of kernel_vertical as the input of kernel_horizontal.
    // Sets temp surface index as the first argument of kernel_horizontal.
    // Sets output surface index as the second argument of kernel_horizontal.
    cm_result_check(kernel_horizontal->SetKernelArg(0,
                                                    sizeof(SurfaceIndex),
                                                    temp_surface_idx));
    cm_result_check(kernel_horizontal->SetKernelArg(1,
                                                    sizeof(SurfaceIndex),
                                                    output_surface_idx));

    // Sets the image width and height as the third and the fourth argument
    // of kernel_horizontal.
    cm_result_check(kernel_horizontal->SetKernelArg(2, 4, &width));
    cm_result_check(kernel_horizontal->SetKernelArg(3, 4, &height));

    // Sets filter coefficients as the rest arguments of kernel_horizontal.
    cm_result_check(kernel_horizontal->SetKernelArg(4, 4, &a0));
    cm_result_check(kernel_horizontal->SetKernelArg(5, 4, &a1));
    cm_result_check(kernel_horizontal->SetKernelArg(6, 4, &a2));
    cm_result_check(kernel_horizontal->SetKernelArg(7, 4, &a3));
    cm_result_check(kernel_horizontal->SetKernelArg(8, 4, &b1));
    cm_result_check(kernel_horizontal->SetKernelArg(9, 4, &b2));
    cm_result_check(kernel_horizontal->SetKernelArg(10, 4, &coefp));
    cm_result_check(kernel_horizontal->SetKernelArg(11, 4, &coefn));

    // Each CmKernel can be executed by multiple concurrent threads.
    // Here, for "kernel_horizontal" kernel, each thread works on
    // NUM_ROWS_PER_THREAD rows in horizontal direction.
    int thread_height = height / NUM_ROWS_PER_THREAD;

    // Creates a CmThreadSpace object.
    // There are two usage models for the thread space. One is to define the
    // dependency between threads to run in the GPU. The other is to define a
    // thread space where each thread can get a pair of coordinates during
    // kernel execution. For this example, we use the latter usage model.
    cm_result_check(device->CreateThreadSpace(thread_height,
                                              1,
                                              thread_space));

    // Creates a CmTask object.
    // The CmTask object is a container for CmKernel pointers. It is used to
    // enqueue the kernels for execution.
    cm_result_check(device->CreateTask(task));

    // Adds a CmKernel pointer to CmTask.
    // This task has one kernels.
    cm_result_check(task->AddKernel(kernel_horizontal));

    // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
    // function returns immediately without waiting for the GPU to start or
    // finish execution of the task. The runtime will query the HW status. If
    // the hardware is not busy, the runtime will submit the task to the
    // driver/HW; otherwise, the runtime will submit the task to the driver/HW
    // at another time.
    // An event, "sync_event", is created to track the status of the task.
    cm_result_check(cmd_queue->Enqueue(task,
                                       sync_event,
                                       thread_space));

    // Destroys a CmTask object.
    // CmTask will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmTask object by itself.
    cm_result_check(device->DestroyTask(task));

    // Reads the output surface content to the system memory using the CPU.
    // The size of data copied is the size of data in Surface.
    // It is a blocking call. The function will not return until the copy
    // operation is completed.
    // The dependent event "sync_event" ensures that the reading of the surface
    // will not happen until its state becomes CM_STATUS_FINISHED.
    cm_result_check(output_surface->ReadSurface(rgba_to_rgb,
                                                sync_event));

    // Destroys the CmDevice.
    // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
    // were created using this device instance that have not explicitly been
    // destroyed by calling the respective destroy functions.
    cm_result_check(::DestroyCmDevice(device));

    // Converts image format from RGBA to RGB.
    unsigned char *tmp = new unsigned char[num_pixels * 3];
    for (int i = 0; i < num_pixels; i++) {
        tmp[i * 3] = rgba_to_rgb[i * 4];
        tmp[i * 3 + 1] = rgba_to_rgb[i * 4 + 1];
        tmp[i * 3 + 2] = rgba_to_rgb[i * 4 + 2];
    }
    output_image.setData(tmp);

    // Saves the output image data into the file "blur_out.bmp".
    output_image.save("blur_out.bmp");

    // Frees memory.
    delete[] rgb_to_rgba;
    delete[] rgba_to_rgb;

    // Checks result.
    if (BitMap::checkResult("blur_out.bmp",
                            "blur_gold.bmp",
                            5)) {
        std::cout << "PASSED" << std::endl;
        return 0;
    } else {
        std::cout << "FAILED" << std::endl;
        return -1;
    }
}
