/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <cm_rt.h>

// Includes bitmap_helpers.h for bitmap file open/save operations.
#include "common/bitmap_helpers.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

// C++ string
#include <string>

int main(int argc, char * argv[]) {
    // This program shows how to use a GPU gen kernel to convert RGB bmp
    // picture into mono color Sepia Tone picture.
    // Sepia tone is a type of monochrome photographic image in which the
    // picture appears in shades of brown as opposed to greyscale as in a
    // black-and-white image. It was originally produced by adding a pigment
    // made from the Sepia cuttlefish to the positive print of a photograph
    // taken with any number of negative processes.

    // File sepia_genx.isa is generated by the CM compiler
    // when it is used to compile kernles in file "sepia_genx.cpp".
    // Reads in the virtual ISA from "sepia_genx.isa" to the code buffer.
    std::string isa_code = cm::util::isa::loadFile("sepia_genx.isa");
    if (isa_code.size() == 0) {
        std::cerr << "Error: empty ISA binary.\n";
        exit(1);
    }

    // Loads a bitmap file named "sepia_in.bmp".
    auto input_image = cm::util::bitmap::BitMap::load("sepia_in.bmp");

    // Gets the width and height of the bitmap file.
    unsigned width = input_image.getWidth();
    unsigned height = input_image.getHeight();

    // Checks the value of width, height and bpp(bits per pixel) of the image.
    // Only images in 8-bit RGB format are supported.
    // Only images with width and height a multiple of 8 are supported.
    if ((width & 7) || (height & 7) || input_image.getBPP() != 24) {
        std::cerr << "Error: Only images in 8-bit RGB format with width and "
                  << "height a multiple of 8 are supported.\n";
        input_image.setData(nullptr);
        std::exit(1);
    }

    // Copies input image to output except for the data.
    auto output_image = input_image;

    // Sets image size in bytes. There are a total of width*height pixels and
    // each pixel occupies (out.getBPP()/8) bytes.
    unsigned img_size = width * height * (output_image.getBPP() / 8);

    // Sets output to blank image.
    output_image.setData(new unsigned char[img_size]);

    // Creates a CmDevice from scratch.
    // Param device: pointer to the CmDevice object.
    // Param version: CM API version supported by the runtime library.
    CmDevice *device = nullptr;
    unsigned int version = 0;
    cm_result_check(::CreateCmDevice(device, version));

    // Creates a CmProgram object consisting of the kernels loaded from the code
    // buffer.
    // Param isa_code.data(): Pointer to the code buffer containing the virtual
    // ISA.
    // Param isa_code.size(): Size in bytes of the code buffer containing the
    // virtual ISA.
    CmProgram *program = nullptr;
    cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                        isa_code.size(),
                                        program));

    // Create the sepia kernel.
    // param program: CM Program from which the kernel is created.
    // param sepia: The kernel name should be no more than 256 bytes including
    // the null terminator.
    CmKernel *kernel_sepia = nullptr;
    cm_result_check(device->CreateKernel(program, "sepia", kernel_sepia));

    // The input image is RGB format with 24 bits per pixel, and the surface
    // format is A8R8G8B8 with 32 bits per pixel. Therefore, the surface width
    // is (width*3/4) in pixels.
    int surface_width = width * 3 / 4;
    int surface_height = height;

    // Creates input surface with given width and height in pixels and format.
    // Sets surface format as CM_SURFACE_FORMAT_A8R8G8B8. For this format, each
    // pixel occupies 32 bits.
    CmSurface2D *input_surface = nullptr;
    cm_result_check(device->CreateSurface2D(surface_width,
                                            surface_height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            input_surface));

    // Copies system memory content to the input surface using the CPU. The
    // system memory content is the data of the input image. The size of data
    // copied is the size of data in the surface.
    cm_result_check(input_surface->WriteSurface(input_image.getData(),
                                                nullptr));

    // Creates the output surface. The width, height and format is the same as
    // the input surface.
    CmSurface2D *output_surface = nullptr;
    cm_result_check(device->CreateSurface2D(surface_width,
                                            surface_height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            output_surface));

    // Each CmKernel can be executed by multiple concurrent threads.
    // threadswidth is equal to surface width divided by 8
    // threadsheight is equal to surface height divided by 6
    int thread_width = width * 3 / 24;
    int thread_height = height / 6;

    // Creates thread space for kernel "sepia".
    CmThreadSpace *thread_space_sepia = nullptr;
    cm_result_check(device->CreateThreadSpace(thread_width,
                                              thread_height,
                                              thread_space_sepia));

    // gets the input surface index associated with the input surface
    SurfaceIndex *input_surface_idx = nullptr;
    cm_result_check(input_surface->GetIndex(input_surface_idx));

    // Kernel argument values are constant for all threads of this kernel
    // sets input surface index as the first argument of sepia kernel
    cm_result_check(kernel_sepia->SetKernelArg(0, sizeof(SurfaceIndex),
                                               input_surface_idx));

    // gets the output surface index associated with the output surface
    SurfaceIndex *output_surface_idx = nullptr;
    cm_result_check(output_surface->GetIndex(output_surface_idx));

    // sets output surface index as the second argument of sepia kernel
    cm_result_check(kernel_sepia->SetKernelArg(1, sizeof(SurfaceIndex),
                                               output_surface_idx));

    // Creates a CmTask object.
    // The CmTask object is a container for CmKernel pointers. It is used to
    // enqueue the kernels for execution.
    CmTask *task = nullptr;
    cm_result_check(device->CreateTask(task));

    // Adds a CmKernel pointer to CmTask
    // This task has only one kernel, which is sepia
    cm_result_check(task->AddKernel(kernel_sepia));

    // Creates a task queue.
    // The CmQueue is an in-order queue. Tasks get executed according to the
    // order they are enqueued. The next task does not start execution until the
    // current task finishes.
    CmQueue *queue = nullptr;
    cm_result_check(device->CreateQueue(queue));

    // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
    // function returns immediately without waiting for the GPU to start or
    // finish execution of the task. The runtime will query the HW status. If
    // the hardware is not busy, the runtime will submit the task to the
    // driver/HW; otherwise, the runtime will submit the task to the driver/HW
    // at another time.
    // An event, "sync_event", is created to track the status of the task.
    CmEvent *sync_event = nullptr;
    cm_result_check(queue->Enqueue(task, sync_event, thread_space_sepia));

    // Destroys a CmTask object.
    // CmTask will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmTask object by itself.
    cm_result_check(device->DestroyTask(task));
    cm_result_check(device->DestroyThreadSpace(thread_space_sepia));

    // Sepia kernel writes the result to the output surface
    // Reads the output surface content to the system memory using the CPU.
    // The size of data copied is the size of data in Surface.
    // It is a blocking call. The function will not return until the copy
    // operation is completed.
    // The dependent event "sync_event" ensures that the reading of the surface
    // will not happen until its state becomes CM_STATUS_FINISHED.
    cm_result_check(output_surface->ReadSurface(output_image.getData(),
                                                sync_event));

    // Queries the execution time of a task in the unit of nanoseconds.
    // The execution time is measured from the time the task started
    // execution in GPU to the time when the task finished execution.
    UINT64 executionTime = 0;
    cm_result_check(sync_event->GetExecutionTime(executionTime));
    std::cout << "Kernel sepia execution time is " << executionTime <<" nanoseconds\n";

    // Destroys the CmEvent.
    // CmEvent must be destroyed by the user explicitly.
    cm_result_check(queue->DestroyEvent(sync_event));

    // Destroys the CmDevice.
    // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
    // were created using this device instance that have not explicitly been
    // destroyed by calling the respective destroy functions.
    cm_result_check(::DestroyCmDevice(device));

    // Saves the output image data into file "sepia_out.bmp".
    output_image.save("sepia_out.bmp");

    // Compares each pixel of output image with gold image. Set the tolerence of
    // each pixel difference as 5. If the difference of all pixel is within this
    // toletence, the result is correct. Otherwise there is something wrong.
    bool passed = cm::util::bitmap::BitMap::checkResult("sepia_out.bmp",
                                                        "sepia_gold.bmp",
                                                        5);

    std::cout << (passed ? "PASSED" : "FAILED");
    std::cout << '\n';
    return (passed ? 0 : -1);
}
