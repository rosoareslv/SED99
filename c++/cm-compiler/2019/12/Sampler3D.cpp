/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <iostream>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"

// Includes bitmap_helpers.h for bitmap file open/save operations.
#include "common/bitmap_helpers.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

// Includes bmp_cmp.h to compare the output image with a golden image.
#include "bmp_cmp.h"

// The 2D size for the image block that will be processed by each thread
#define BLOCK_PIXEL_WIDTH (8)
#define BLOCK_HEIGHT (2)

// The main function used for the sampler example
bool TestSamplerA8R8G8B8() {
    // This example shows how to use the hardware sampler to process the image.
    // In this example, the image will be divided into blocks of 16 pixels in
    // the size of two rows by eight columns. Each image block will be
    // processed by one hardware thread. In the kernel, the sampler coordinates
    // are provided to the sample16 function to get the output sampled pixels
    // which will be written to the output image.

    // Loads an input image from file "image_in.bmp"
    // Creates a BitMap, output image, from input_image. The input_image member
    // variables' data are copied over excluding the input_image content.
    auto input_image = cm::util::bitmap::BitMap::load("Input.bmp");
    auto output_image(input_image);

    // This is the declaration of the image size, and the 4-channel
    // intermediate image data used by CM. The input/output images are
    // 3-channel images, therefore an extra step is needed to convert between
    // the input/output images and the intermediate image data.
    unsigned int width = input_image.getWidth();
    unsigned int height = input_image.getHeight();
    std::cout << "WIDTH=" << width << "  HEIGHT=" << height << std::endl;

    // Allocates the intermediate 4-channel image data based on image size.
    unsigned char *input_data_4ch = new unsigned char[width * height * 4];
    unsigned char *output_data_4ch = new unsigned char[width * height * 4];

    // Sets image size in bytes. There are a total of width*height pixels and
    // each pixel occupies (out.getBPP()/8) bytes.
    unsigned output_image_size = width * height * output_image.getBPP() / 8;
    // Sets output to a new content.
    output_image.setData(new unsigned char[output_image_size]);

    // Checks the value of width, height and bpp(bits per pixel) of the image.
    // Only images in 8-bit RGB format are supported.
    // Only images with width and height a multiple of 8 are supported.
    if ((width & 7) || (height & 7) || input_image.getBPP() != 24) {
        std::cerr << "Error: Only images in 8-bit RGB format with width and "
                  << "height a multiple of 8 are supported." << std::endl;
        exit(1);
    }

    // Pads the input_image from three channels (RGB) to four channels (ARGB)
    unsigned char *temp_src1 = input_image.getData();
    if (temp_src1 == nullptr) {
        std::cerr << "Error: failed to read the input image" << std::endl;
        exit(1);
    }
    unsigned char *temp_src2 = input_data_4ch;
    for (int counter = 0; counter < width * height; counter++) {
        temp_src2[0] = temp_src1[0];
        temp_src2[1] = temp_src1[1];
        temp_src2[2] = temp_src1[2];
        temp_src2[3] = 0;
        temp_src1 += 3;
        temp_src2 += 4;
    }

    // Creates a CmDevice from scratch.
    // Param device: pointer to the CmDevice object.
    // Param version: CM API version supported by the runtime library.
    CmDevice *device = nullptr;;
    unsigned int version = 0;
    cm_result_check(CreateCmDevice(device, version));

    // The file Sampler3D_genx.isa is generated when the kernels in the file
    // Sampler3D_genx.cpp are compiled by the CM compiler. There is one
    // kernel included here, "samplerExample".
    // Reads in the virtual ISA from "Sampler3D_genx.isa" to the code
    // buffer.
    std::string isa_code = cm::util::isa::loadFile("Sampler3D_genx.isa");
    if (isa_code.size() == 0) {
        std::cerr << "Error: empty ISA binary." << std::endl;
        exit(1);
    }

    // Creates a CmProgram object consisting of the kernels loaded from the
    // code buffer.
    // Param isa_code.data(): Pointer to the code buffer containing the virtual
    // ISA.
    // Param isa_code.size(): Size in bytes of the code buffer containing the
    // virtual ISA.
    CmProgram *program = nullptr;
    cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                        isa_code.size(),
                                        program));

    // Creates the sampler kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "samplerExample": The kernel name which should be no more than
    // 256 bytes including the null terminator.
    CmKernel *kernel = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "samplerExample",
                                         kernel));

    // Creates sampler with linear filter and clamp address mode.
    CmSampler *sampler = nullptr;
    CM_SAMPLER_STATE sampler_state;
    sampler_state.magFilterType = CM_TEXTURE_FILTER_TYPE_LINEAR;
    sampler_state.minFilterType = CM_TEXTURE_FILTER_TYPE_LINEAR;
    sampler_state.addressU = CM_TEXTURE_ADDRESS_CLAMP;
    sampler_state.addressV = CM_TEXTURE_ADDRESS_CLAMP;
    sampler_state.addressW = CM_TEXTURE_ADDRESS_CLAMP;
    cm_result_check(device->CreateSampler(sampler_state, sampler));

    // Creates input surface with given width and height in pixels and format.
    // Sets surface format as CM_SURFACE_FORMAT_A8R8G8B8. For this format, each
    // pixel occupies 32 bits.
    CmSurface2D *surface_input = nullptr;
    cm_result_check(device->CreateSurface2D(width,
                                            height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            surface_input));

    // Copies system memory content to the input surface using the CPU. The
    // system memory content is the data of the input image. The size of data
    // copied is the size of data in the surface.
    cm_result_check(surface_input->WriteSurface(input_data_4ch, nullptr));

    // Creates output surface with given width and height in pixels and format.
    // Sets surface format as CM_SURFACE_FORMAT_A8R8G8B8. For this format, each
    // pixel occupies 32 bits.
    CmSurface2D *surface_output = nullptr;
    cm_result_check(device->CreateSurface2D(width,
                                            height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            surface_output));

    // The sizes should be divisible according to kernel's expectations.
    if ((width % BLOCK_PIXEL_WIDTH) != 0) {
        std::cout << "Width (=" << width
                  << ") - Cannot divide into exact blocks of width "
                  << BLOCK_PIXEL_WIDTH << std::endl;
        exit(1);
    }
    if ((height % BLOCK_HEIGHT) != 0) {
        std::cout << "Height (=" << height
                  << ") - Cannot divide into exact blocks of height "
                  << BLOCK_HEIGHT << std::endl;
        exit(1);
    }

    // Each CmKernel can be executed by multiple concurrent threads.
    // Here, for "samplerExample" kernel, each thread works on a block of 2x8
    // pixels. The thread width is equal to input image width divided by 8.
    // The thread height is equal to input image height divided by 2.
    int thread_width = width / BLOCK_PIXEL_WIDTH;
    int thread_height = height / BLOCK_HEIGHT;
    std::cout << "Thread count = " << thread_width << " x " << thread_height
              << " = " << thread_width*thread_height << std::endl;

    // Creates a CmThreadSpace object.
    // There are two usage models for the thread space. One is to define the
    // dependency between threads to run in the GPU. The other is to define a
    // thread space where each thread can get a pair of coordinates during
    // kernel execution. For this example, we use the latter usage model.
    CmThreadSpace *thread_space = nullptr;
    cm_result_check(device->CreateThreadSpace(thread_width,
                                              thread_height,
                                              thread_space));

    // Kernel arg 0: index of the sampler.
    SamplerIndex *sampler_index = nullptr;
    cm_result_check(sampler->GetIndex(sampler_index));
    cm_result_check(kernel->SetKernelArg(0,
                                         sizeof(SamplerIndex),
                                         sampler_index));

    // Kernel arg 1: index of the surface that needs to be sampled.
    SurfaceIndex *sampler_surface_index = nullptr;
    cm_result_check(device->CreateSamplerSurface2D(surface_input,
                                                   sampler_surface_index));
    cm_result_check(kernel->SetKernelArg(1,
                                         sizeof(SurfaceIndex),
                                         sampler_surface_index));

    // Kernel arg 2: index of the output surface which is the result.
    SurfaceIndex *surface_output_index = nullptr;
    cm_result_check(surface_output->GetIndex(surface_output_index));
    cm_result_check(kernel->SetKernelArg(2,
                                         sizeof(SurfaceIndex),
                                         surface_output_index));

    float coord_unit_u = 1.0f / static_cast<float>(width);
    float coord_unit_v = 1.0f / static_cast<float>(height);

    // Kernel arg 3: the unit of texture coordinate on X axis
    cm_result_check(kernel->SetKernelArg(3, 4, &coord_unit_u));

    // Kernel arg 4: the unit of texture coordinate on Y axis
    cm_result_check(kernel->SetKernelArg(4, 4, &coord_unit_v));

    // Creates a task queue.
    // The CmQueue is an in-order queue. Tasks get executed according to the
    // order they are enqueued. The next task does not start execution until the
    // current task finishes.
    CmQueue *queue = nullptr;
    cm_result_check(device->CreateQueue(queue));

    // Creates a CmTask object.
    // The CmTask object is a container for CmKernel pointers. It is used to
    // enqueue the kernels for execution.
    CmTask *task = nullptr;
    cm_result_check(device->CreateTask(task));

    // Adds a CmKernel pointer to CmTask.
    cm_result_check(task->AddKernel(kernel));

    // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
    // function returns immediately without waiting for the GPU to start or
    // finish execution of the task. The runtime will query the HW status. If
    // the hardware is not busy, the runtime will submit the task to the
    // driver/HW; otherwise, the runtime will submit the task to the driver/HW
    // at another time.
    // An event, "sync_event", is created to track the status of the task.
    CmEvent *sync_event = nullptr;
    cm_result_check(queue->Enqueue(task, sync_event, thread_space));

    // Destroys a CmTask object.
    // CmTask will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmTask object by itself.
    cm_result_check(device->DestroyTask(task));

    // Reads the output surface content to the system memory using the CPU.
    // The size of data copied is the size of data in Surface.
    // It is a blocking call. The function will not return until the copy
    // operation is completed.
    // The dependent event "sync_event" ensures that the reading of the surface
    // will not happen until its state becomes CM_STATUS_FINISHED.
    cm_result_check(surface_output->ReadSurface(output_data_4ch, sync_event));

    // Destroys the CmDevice.
    // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
    // were created using this device instance that have not explicitly been
    // destroyed by calling the respective destroy functions.
    cm_result_check(DestroyCmDevice(device));

    // Converts the image from four channels (ARGB) back to three channels (RGB)
    unsigned char *temp_dst1 = output_image.getData();
    unsigned char *temp_dst2 = output_data_4ch;
    for (int counter = 0; counter < width * height;) {
        temp_dst1[0] = temp_dst2[0];
        temp_dst1[1] = temp_dst2[1];
        temp_dst1[2] = temp_dst2[2];
        temp_dst1 += 3;
        temp_dst2 += 4;
        counter++;
        if ((counter % width) == 0) {
            temp_dst1 = &output_image.getData()[(counter / width) * width * 3];
        }
    }

    // Saves and compares the output result with gold file sampler_gold.bmp
    output_image.save("Output_CM.bmp");
    bool passed = BMP_Check_Result("Output_CM.bmp", "sampler_gold.bmp", 5);

    delete[] input_data_4ch;
    delete[] output_data_4ch;
    return passed;
}

int main(int argc, char *argv[]) {
    std::cout << "Start running example Sampler3D" << std::endl;
    bool passed = TestSamplerA8R8G8B8();

    std::cout << "FINISHED RUNNING" << std::endl;
    if (passed) {
        std::cout << "PASSED" << std::endl;
    } else {
        std::cout << "FAILED" << std::endl;
    }
    return (passed ? 0 : -1);
}
