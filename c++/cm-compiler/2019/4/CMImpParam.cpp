/*
 * Copyright (c) 2019, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

//===----------------------------------------------------------------------===//
//
/// CMImpParam
/// ----------
/// 
/// As well as explicit kernel args declared in the CM kernel function, certain
/// implicit args are also passed. These fall into two categories:
/// 
/// 1. fields set up in r0 by the hardware, depending on which dispatch method
///    is being used (e.g. media walker);
/// 
/// 2. implicit args set up along with the explicit args in CURBE by the CM
///    runtime.
/// 
/// The r0 implicit args are represented in LLVM IR by special intrinsics, and the
/// GenX backend generates these to special reserved vISA registers.
/// 
/// For the CM runtime implicit args in (2) above, in vISA 3.2 and earlier, these were also
/// represented by LLVM special intrinsics and vISA special reserved vISA registers.
/// Because they are specific to the CM runtime, and not any other user of vISA,
/// vISA 3.3 has removed them, and instead they are handled much like other kernel
/// args in the input table.
///
/// The *kind* byte in the input table has two fields:
///
/// * the *category* field, saying whether the input is general/surface/etc;
///
/// * the *provenance* field, saying whether the input is an explicit one from
///   the CM source, or an implicit one generated by this pass. This is a
///   protocol agreed between the CM compiler (in fact this pass) and the CM
///   runtime.
/// 
/// Within the CM compiler, the vISA input table for a kernel is represented by an
/// array of kind bytes, each one corresponding to an argument of the kernel function.
/// 
/// Clang codegen still generates special intrinsics for these CM runtime implicit
/// args. It is the job of this CMImpParam pass to transform those intrinsics:
/// 
/// * where the intrinsic for a CM runtime implicit arg is used somewhere:
/// 
///   - a global variable is created for it;
///     
///   - for any kernel that uses the implicit arg (or can reach a subroutine that
///     uses it), the implicit arg is added to the input table in the kernel
///     metadata and as an extra arg to the definition of the kernel itself,
///     and its value is stored into the global variable;
/// 
/// * each use of the intrinsic for a CM runtime implicit arg is transformed into
///   a load of the corresponding global variable.
/// 
/// Like any other global variable, the subsequent CMABI pass turns the global
/// variable for an implicit arg into local variable(s) passed into subroutines
/// if necessary.
///
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "cmimpparam"
#include "llvm/Transforms/Scalar.h"
#include "llvm/ADT/SetVector.h"
#include "llvm/ADT/SCCIterator.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/Analysis/CallGraph.h"
#include "llvm/Analysis/CallGraphSCCPass.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/Function.h"

#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Module.h"
#include "llvm/Pass.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
#include <set>
#include <map>

using namespace llvm;

namespace llvm {
// Provide DenseMapInfo for Intrinsic::ID
template <> struct DenseMapInfo<Intrinsic::ID> {
  static inline Intrinsic::ID getEmptyKey() { return Intrinsic::not_intrinsic; }
  static inline Intrinsic::ID getTombstoneKey() {
    return (Intrinsic::ID)(~0U - 1);
  }
  static unsigned int getHashValue(const Intrinsic::ID &Val) {
    return (uint32_t)Val * 37U;
  }
  static bool isEqual(const Intrinsic::ID &LHS, const Intrinsic::ID &RHS) {
    return LHS == RHS;
  }
};
}

namespace {

class ImplicitUseInfo {
public:
  typedef std::set<Intrinsic::ID> ImplicitSetTy;

  explicit ImplicitUseInfo(Function *F) : Fn(F) {}
  ImplicitUseInfo() : Fn(nullptr) {}

  Function *getFunction() const { return Fn; }

  bool empty() const { return Implicits.empty(); }
  ImplicitSetTy &getImplicits() { return Implicits; }
  const ImplicitSetTy &getImplicits() const { return Implicits; }

  // \brief Add an implicit arg intrinsic
  void addImplicit(Intrinsic::ID IID) { Implicits.insert(IID); }

  void merge(const ImplicitUseInfo &IUI) {
    Implicits.insert(IUI.Implicits.begin(), IUI.Implicits.end());
  }

  void dump() const { print(dbgs()); }

  void print(raw_ostream &OS, unsigned depth = 0) const {
    for (auto IID : Implicits) {
      OS.indent(depth) << Intrinsic::getName(IID, None) << "\n";
    }
  }

private:
  // \brief The function being analyzed
  Function *Fn;

  // \brief Implicit arguments used
  ImplicitSetTy Implicits;
};

struct CMImpParam : public ModulePass {
  static char ID;

  CMImpParam() : ModulePass(ID) {
    initializeCMImpParamPass(*PassRegistry::getPassRegistry());
  }

  virtual void getAnalysisUsage(AnalysisUsage &AU) const {
    AU.addRequired<CallGraphWrapperPass>();
  }

  virtual StringRef getPassName() const { return "CM Implicit Params"; }

  virtual bool runOnModule(Module &M);

  void dump() const { print(dbgs()); }
  virtual void print(raw_ostream &OS, const Module *M = nullptr) const;

private:
  void replaceWithGlobal(CallInst *CI, Intrinsic::ID IID);
  bool AnalyzeImplicitUse(Module &M);
  void MergeImplicits(ImplicitUseInfo &implicits, Function *F);
  void PropagateImplicits(Function *F, Module &M,
                          ImplicitUseInfo &implicits);
  CallGraphNode *ProcessKernel(Function *F);

  // All the Kinds defined
  // These correspond to the values used in vISA
  // Bits 0-1 represent category (see enum)
  // Bits 7..3 represent the value needed for the runtime to determine what
  //           the implicit argument should be
  //
  enum ImpCategory { IMP_GENERAL, IMP_SAMPLER, IMP_SURFACE, IMP_VME };
  enum ImpValue { IMP_NONE = 0x0,
                  IMP_LOCAL_SIZE  = 0x1 << 3,
                  IMP_GROUP_COUNT = 0x2 << 3,
                  IMP_LOCAL_ID    = 0x3 << 3,
                  IMP_SB_DELTAS   = 0x4 << 3,
                  IMP_SB_BTI      = 0x5 << 3,
                  IMP_SB_DEPCNT   = 0x6 << 3};
  
  uint32_t MapToKind(Intrinsic::ID IID) {
    switch (IID) {
      default:
        return IMP_NONE;
      case llvm::Intrinsic::genx_local_size:
        return IMP_GENERAL | IMP_LOCAL_SIZE;
      case llvm::Intrinsic::genx_local_id:
        return IMP_GENERAL | IMP_LOCAL_ID;
      case llvm::Intrinsic::genx_group_count:
        return IMP_GENERAL | IMP_GROUP_COUNT;
      case llvm::Intrinsic::genx_get_scoreboard_deltas:
        return IMP_GENERAL | IMP_SB_DELTAS;
      case llvm::Intrinsic::genx_get_scoreboard_bti:
        return IMP_SURFACE | IMP_SB_BTI;
      case llvm::Intrinsic::genx_get_scoreboard_depcnt:
        return IMP_SURFACE | IMP_SB_DEPCNT;
    }
    
    return IMP_NONE;
  }
  
  // \brief Returns the implicit use info associated with a function
  ImplicitUseInfo &getImplicitUseInfo(Function *F) {
    if (!ImplicitsInfo.count(F)) {
      ImplicitUseInfo *IUI = new ImplicitUseInfo(F);
      ImplicitsInfoObjs.push_back(IUI);
      ImplicitsInfo[F] = IUI;
      return *IUI;
    }
    return *ImplicitsInfo[F];
  }

  // \brief Returns the implict use info associated with a function (kernel)
  // and also creates
  // a new one that represents the total implicits for the kernel as a whole
  // (stored in a
  // different object)
  ImplicitUseInfo &getImplicitUseInfoKernel(Function *F) {
    assert(Kernels.count(F));

    if (KernelsInfo.count(F)) {
      // Kernel already processed
      return *KernelsInfo[F];
    }

    ImplicitUseInfo *IUI = new ImplicitUseInfo(F);
    ImplicitsInfoObjs.push_back(IUI);
    KernelsInfo[F] = IUI;

    if (ImplicitsInfo.count(F)) {
      IUI->merge(*ImplicitsInfo[F]);
    }

    return *IUI;
  }

  const ImplicitUseInfo *implicitUseInfoKernelExist(Function *F) const {
    if (KernelsInfo.count(F)) {
      auto CI = KernelsInfo.find(F);
      return CI->second;
    }

    return nullptr;
  }

  void addImplicit(Function *F, Intrinsic::ID IID) {
    getImplicitUseInfo(F).addImplicit(IID);
  }

  GlobalVariable *getIIDGlobal(Function *F, Intrinsic::ID IID) {
    if (GlobalsMap.count(IID))
      return GlobalsMap[IID];

    Type * Ty = getIntrinRetType(F->getContext(), IID);
    assert(Ty);
    GlobalVariable *NewVar = new GlobalVariable(
        *F->getParent(), Ty, false,
        GlobalVariable::InternalLinkage,
        Constant::getNullValue(Ty),
        "__imparg_" + Intrinsic::getName(IID, None));
    GlobalsMap[IID] = NewVar;

    return NewVar;
  }
  
  Type *getIntrinRetType(LLVMContext &Context, Intrinsic::ID IID) {
    switch (IID) {
      case Intrinsic::genx_local_id:
      case Intrinsic::genx_local_size:
      case Intrinsic::genx_group_count:
        return llvm::VectorType::get(llvm::Type::getInt32Ty(Context), 3);
      default:
        // Should be able to extract the type from the intrinsic
        // directly as no overloading is required (if it is then
        // you need to define specific type in a case statement above)
        FunctionType *FTy = dyn_cast_or_null<FunctionType>(
                                    Intrinsic::getType(Context, IID));
        if (FTy)
          return FTy->getReturnType();
    }
    return nullptr;
  }

  // This map captures all implicit uses to be transformed
  SmallDenseMap<Function *, ImplicitUseInfo *> ImplicitsInfo;

  // This map captures all implicit uses that are required for a kernel
  // (includes sub function uses)
  SmallDenseMap<Function *, ImplicitUseInfo *> KernelsInfo;

  // All kernels (entry points) in module being processed
  SmallPtrSet<Function *, 8> Kernels;

  // Already visited functions
  SmallPtrSet<Function *, 8> AlreadyVisited;

  // ImplicitUseInfo objects created
  SmallVector<ImplicitUseInfo *, 8> ImplicitsInfoObjs;

  // Functions that contain implicit arg intrinsics
  SmallPtrSet<Function *, 8> ContainImplicit;

  // GlobalVariables that have been created for an intrinsic
  SmallDenseMap<Intrinsic::ID, GlobalVariable *> GlobalsMap;
};

} // namespace

bool CMImpParam::runOnModule(Module &M) {
  bool changed = false;

  // Analyze functions for implicit use intrinsic invocation
  changed = AnalyzeImplicitUse(M);

  auto getValue = [](Metadata *M) -> Value * {
    if (auto VM = dyn_cast<ValueAsMetadata>(M))
      return VM->getValue();
    return nullptr;
  };

  // Collect all CM kernels from named metadata
  // and also traverse the call graph to determine what the total implicit uses
  // are for the top
  // level kernels
  if (NamedMDNode *Named = M.getNamedMetadata("genx.kernels")) {
    for (unsigned I = 0, E = Named->getNumOperands(); I != E; ++I) {
      MDNode *Node = Named->getOperand(I);
      if (Function *F =
              dyn_cast_or_null<Function>(getValue(Node->getOperand(0)))) {
        Kernels.insert(F);
        AlreadyVisited.clear();
        ImplicitUseInfo &implicits = getImplicitUseInfoKernel(F);
        PropagateImplicits(F, M, implicits);
        if (!implicits.empty()) {
          ProcessKernel(F);
          changed |= true;
        }
      }
    }
  }
  
  for (ImplicitUseInfo *Obj : ImplicitsInfoObjs)
    delete Obj;

  return changed;
}

// Replace the given instruction with a load from a global
void CMImpParam::replaceWithGlobal(CallInst *CI, Intrinsic::ID IID) {
  GlobalVariable *GV = getIIDGlobal(CI->getParent()->getParent(), IID);
  LoadInst *Load = new LoadInst(GV, GV->getName() + ".val", CI);
  CI->replaceAllUsesWith(Load);
}

// For each function, see if it uses an intrinsic that in turn requires an
// implicit kernel argument
// (such as llvm.genx.local.size)
bool CMImpParam::AnalyzeImplicitUse(Module &M) {
  bool changed = false;

  for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I) {
    Function *Fn = &*I;
    DEBUG(dbgs() << "AnalyzeImplicitUse visiting " << Fn->getName());

    bool implicitUse = false;

    SmallVector<CallInst *, 8> ToErase;

    // FIXME I think this should scan function declarations to find the implicit
    // arg intrinsics, then scan their uses, instead of scanning the whole code
    // to find calls to them.
    for (inst_iterator II = inst_begin(Fn), IE = inst_end(Fn); II != IE; ++II) {
      Instruction *Inst = &*II;
      if (CallInst *CI = dyn_cast<CallInst>(Inst)) {
        if (Function *Callee = CI->getCalledFunction()) {
          Intrinsic::ID IID = (Intrinsic::ID)Callee->getIntrinsicID();
          if (IID != Intrinsic::not_intrinsic) {
            switch (IID) {
              case Intrinsic::genx_local_size:
              case Intrinsic::genx_local_id:
              case Intrinsic::genx_group_count:
              case Intrinsic::genx_get_scoreboard_deltas:
              case Intrinsic::genx_get_scoreboard_bti:
              case Intrinsic::genx_get_scoreboard_depcnt:
                DEBUG(dbgs() << "AnalyzeImplicitUse found "
                             << Intrinsic::getName(IID, None));
                addImplicit(Fn, IID);
                implicitUse = true;

                // Replace the intrinsic with a load of a global at this point
                replaceWithGlobal(CI, IID);
                ToErase.push_back(CI);
                changed = true;
                break;
              default:
                // Ignore (default added to prevent compiler warnings)
                break;
            }
          }
        }
      }
    }

    for (auto CI : ToErase)
      CI->eraseFromParent();

    // Mark this function as containing an implicit use intrinsic
    if (implicitUse) {
      ContainImplicit.insert(Fn);
    }
  }

  return changed;
}

// Merge implicit uses from the supplied function with implicit set passed in
void CMImpParam::MergeImplicits(ImplicitUseInfo &implicits, Function *F) {
  assert(ImplicitsInfo.count(F) && "Function not found in implicits info map");
  auto IInfo = ImplicitsInfo[F];
  implicits.merge(*IInfo);
}

// Determine if the named function uses any functions tagged with implicit use
// in the call-graph
void CMImpParam::PropagateImplicits(Function *F, Module &M,
                                    ImplicitUseInfo &implicits) {
  // Traverse the call graph from the Kernel to determine what implicits are
  // used
  CallGraph &CG = getAnalysis<CallGraphWrapperPass>().getCallGraph();
  
  // If this node has already been processed then return immediately
  if (AlreadyVisited.count(F))
    return;

  // Add this node to the already visited list
  AlreadyVisited.insert(F);

  // Start the traversal
  CallGraphNode *N = CG[F];
  // Inspect all children (recursive)
  for (auto Children : *N) {
    auto Func = Children.second->getFunction();
    // Does this function have implicit arg use?
    if (ContainImplicit.count(Func)) {
      // Yes - add the implicits it contains to the set so far
      MergeImplicits(implicits, Func);
    }
    // Also recursively process children of this node
    PropagateImplicits(Func, M, implicits);
  }
}

// Process a kernel - loads from a global (and the globals) have already been
// added if required elsewhere (in doInitialization)
// We've already determined that this is a kernel and that it requires some
// implicit arguments adding
CallGraphNode *CMImpParam::ProcessKernel(Function *F) {
  LLVMContext &Context = F->getContext();
  
  assert(Kernels.count(F) && "ProcessKernel invoked on non-kernel CallGraphNode");
  assert(KernelsInfo.count(F) &&
         "ProcessKernel invoked on kernel that doesn't require transforming");

  AttributeList AttrVec;
  const AttributeList &PAL = F->getAttributes();
  
  // Determine the new argument list
  SmallVector<Type *, 8> ArgTys;
  
  // First transfer all the explicit arguments from the old kernel
  unsigned ArgIndex = 0;
  for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
       ++I, ++ArgIndex) {
    ArgTys.push_back(I->getType());
    AttributeSet attrs = PAL.getParamAttributes(ArgIndex);
    if (attrs.hasAttributes()) {
      AttrBuilder B(attrs);
      AttrVec = AttrVec.addParamAttributes(Context, ArgIndex, B);
    }
  }
  
  // Now add all the implicit arguments
  ImplicitUseInfo *IUI = KernelsInfo[F];
  for (Intrinsic::ID IID : IUI->getImplicits()) {
    ArgTys.push_back(getIntrinRetType(Context, IID));
    // TODO: Might need to also add any attributes from the intrinsic at some
    // point
  }
  
  FunctionType *NFTy = FunctionType::get(F->getReturnType(), ArgTys, false);
  assert((NFTy != F->getFunctionType()) &&
         "type out of sync, expect bool arguments)");
  
  // Add any function attributes
  AttributeSet FnAttrs = PAL.getFnAttributes();
  if (FnAttrs.hasAttributes()) {
    AttrBuilder B(FnAttrs);
    AttrVec = AttrVec.addAttributes(Context, AttributeList::FunctionIndex, B);
  }

  // Create new function body and insert into the module
  Function *NF = Function::Create(NFTy, F->getLinkage(), F->getName());
  NF->setAttributes(AttrVec);
  DEBUG(dbgs() << "CMImpParam: Transforming to: " << *NF << "\n" << "From: "
        << *F);
  F->getParent()->getFunctionList().insert(F->getIterator(), NF);
  NF->takeName(F);
  NF->setSubprogram(F->getSubprogram()); // tranfer debug-info
  
  // Now to splice the body of the old function into the new function
  NF->getBasicBlockList().splice(NF->begin(), F->getBasicBlockList());
  
  // Loop over the argument list, transferring uses of the old arguments to the
  // new arguments, also tranferring over the names as well
  Function::arg_iterator I2 = NF->arg_begin();
  for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
       ++I, ++I2) {
    I->replaceAllUsesWith(I2);
    I2->takeName(I);
  }
  
  // Get the insertion point ready for stores to globals
  Instruction &FirstI = *NF->getEntryBlock().begin();
  llvm::SmallVector<uint32_t, 8> ImpKinds;
  
  for (Intrinsic::ID IID : IUI->getImplicits()) {
    // We known that for each IID implicit we've already added an arg
    // Rename the arg to something more meaningful here
    assert(I2 != NF->arg_end() &&
           "fewer parameters for new function than expected");
    I2->setName("__arg_" + Intrinsic::getName(IID, None));
    
    // Also insert a new store at the start of the function to the global
    // variable used for this implicit argument intrinsic
    assert(GlobalsMap.count(IID) && "no global associated with this imp arg intrinsic");
    new StoreInst(I2, GlobalsMap[IID], &FirstI);
    
    // Prepare the kinds that will go into the metadata
    ImpKinds.push_back(MapToKind(IID));

    ++I2;
  }
  
  CallGraph &CG = getAnalysis<CallGraphWrapperPass>().getCallGraph();
  CallGraphNode *NF_CGN = CG.getOrInsertFunction(NF);
  
  // Update the metadata entry
  assert(F->hasDLLExportStorageClass());
  NF->setDLLStorageClass(F->getDLLStorageClass());
  
  // Scan the CM kernel metadata and replace with NF
  if (NamedMDNode *Named = CG.getModule().getNamedMetadata("genx.kernels")) {
    for (unsigned I = 0, E = Named->getNumOperands(); I != E; ++I) {
      MDNode *Node = Named->getOperand(I);
      if (auto VM = dyn_cast_or_null<ValueAsMetadata>(Node->getOperand(0))) {
        if (F == VM->getValue()) {
          Node->replaceOperandWith(0, ValueAsMetadata::get(NF));
          llvm::SmallVector<llvm::Metadata *, 8> ArgKinds;

          // Create a new MDNode of Kinds
          // First add all the current Kinds for explicit operands
          MDNode *TypeNode = dyn_cast<MDNode>(Node->getOperand(3));
          assert(TypeNode);
          for (unsigned i = 0; i < TypeNode->getNumOperands(); ++i)
            ArgKinds.push_back(TypeNode->getOperand(i));
          for (uint32_t Kind : ImpKinds)
            ArgKinds.push_back(ValueAsMetadata::getConstant(
                ConstantInt::get(Type::getInt32Ty(Context), Kind)));
          llvm::MDNode *Kinds = llvm::MDNode::get(Context, ArgKinds);
          Node->replaceOperandWith(3, Kinds);
        }
      }
    }
  }

  // Now that the old function is dead, delete it. If there is a dangling
  // reference to the CallGraphNode, just leave the dead function around
  NF_CGN->stealCalledFunctionsFrom(CG[F]);
  CallGraphNode *CGN = CG[F];
  if (CGN->getNumReferences() == 0)
    delete CG.removeFunctionFromModule(CGN);
  else
    F->setLinkage(Function::ExternalLinkage);
  
  return NF_CGN;
}

void CMImpParam::print(raw_ostream &OS, const Module *M) const {
  OS << "Kernels : \n";

  for (auto Func : Kernels) {
    OS.indent(4) << Func->getName() << "\n";

    const ImplicitUseInfo *IUI = implicitUseInfoKernelExist(Func);
    if (IUI)
      IUI->print(OS, 8);
  }

  OS << "Functions with implicit arg intrinsics : \n";

  for (auto FuncInfoPair : ImplicitsInfo) {
    OS.indent(4) << FuncInfoPair.first->getName() << "\n";

    FuncInfoPair.second->print(OS, 8);
  }
}


char CMImpParam::ID = 0;
INITIALIZE_PASS_BEGIN(CMImpParam, "cmimpparam",
                      "Transformations required to support implicit arguments",
                      false, false)
INITIALIZE_PASS_DEPENDENCY(CallGraphWrapperPass)
INITIALIZE_PASS_END(CMImpParam, "cmimpparam",
                    "Transformations required to support implicit arguments",
                    false, false)

Pass *llvm::createCMImpParamPass() { return new CMImpParam(); }
