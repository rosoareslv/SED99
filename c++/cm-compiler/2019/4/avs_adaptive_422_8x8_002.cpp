/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <iostream>
#include <string>
#include <cstdint>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

// AVS coefficient tables
// Y Horizontal Table
float Tbl0X[CM_NUM_COEFF_ROWS][8] = {
  // Following lines represent Phase 0 to Phase 16 respectively
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
};

// Y Vertical Table
float Tbl0Y[CM_NUM_COEFF_ROWS][8] = {
  // Following lines represent Phase 0 to Phase 16 respectively
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
};

// UV Horizontal Table
float Tbl1X[CM_NUM_COEFF_ROWS][8] = {
  // Following lines represent Phase 0 to Phase 16 respectively
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
};

// UV Vertical Table
float Tbl1Y[CM_NUM_COEFF_ROWS][8] = {
  // Following lines represent Phase 0 to Phase 16 respectively
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
  { 0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000,0.125000},
};

void delete_buffers(void *x, void *y, void *z) {
  if (x) delete[] x;
  if (y) delete[] y;
  if (z) delete[] z;
}

int main(int argc, char *argv[]) {
  // This program demos the usage of CM sampler. It uses GPU sampler8x8 to
  // carry out 1x AVS scaling on one 16x4 block for a YUY2 surface

  // Input frame
  int frame_width = 64;
  int frame_height = 32;
  float frame_factor = 2.0f;

  // Output frame
  int out_frame_width = 16;
  int out_frame_height = 48;
  float out_frame_factor = 2.0f;

  // Image block size
  int block_width = 16;
  int block_height = 4;

  // Image files for input, output and gold
  char *input_file = "source.uyvy";
  char *output_file = "source_out.yuy2";
  char *gold_file = "avs_adaptive_422_8x8_002.fs.yuy2";

  // Opens input file
  FILE *input_file_handle = fopen(input_file, "rb");
  if (input_file_handle == nullptr) {
    printf("Error opening %s\n", input_file);
    fcloseall();
    return -1;
  }

  // Opens output file
  FILE *output_file_handle = fopen(output_file, "wb");
  if (output_file_handle == nullptr) {
    printf("Error opening %s\n", output_file);
    fcloseall();
    return -1;
  }

  // Opens gold_file.
  FILE *golden_file_handle = fopen(gold_file, "rb");
  if (golden_file_handle == nullptr) {
    perror("Error openning golden output file");
    fcloseall();
    return -1;
  }

  // Finds the glod_file size
  fseek(golden_file_handle, 0, SEEK_END);
  int golden_file_size = ftell(golden_file_handle);
  rewind(golden_file_handle);

  // Allocates memory
  int frame_size = static_cast<int>(frame_width * frame_height * frame_factor);
  unsigned char *input_buffer = new (std::nothrow) BYTE[frame_size];
  int out_frame_size = frame_size * 3 / 8;
  unsigned char *output_buffer = new (std::nothrow) BYTE[out_frame_size];

  // Allocates memory to read gold_file
  unsigned char *golden_buffer = new (std::nothrow) BYTE[golden_file_size];

  if (!input_buffer || !output_buffer || !golden_buffer) {
    printf("Allocate memory fail!\n");
    delete_buffers(input_buffer, output_buffer, golden_buffer);
    fcloseall();
    return -1;
  }

  // Reads a frame of YUY2 data
  if (fread(input_buffer, sizeof(char), frame_size, input_file_handle)
      != frame_size) {
    printf("Unable to read a frame of data.");
    delete_buffers(input_buffer, output_buffer, golden_buffer);
    fcloseall();
    return -1;
  }
  fclose(input_file_handle);

  // Loads isa file into memeory, this isa file is generated from
  // avs_adaptive_422_8x8_002_genx.cpp by CM compiler
  std::string isa_code = cm::util::isa::loadFile(
    "avs_adaptive_422_8x8_002_genx.isa");
  if (isa_code.size() == 0) {
    std::cerr << "Error: empty ISA binary.\n";
    delete_buffers(input_buffer, output_buffer, golden_buffer);
    fcloseall();
    return -1;
  }

  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));

  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                      isa_code.size(),
                                      program));

  // Creates the PA_444AVS_PA kernel.
  // Param program: CM Program from which the kernel is created.
  // Param "PA_444AVS_PA": The kernel name which should be no more than 256 bytes
  // including the null terminator.
  CmKernel *kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
                                       "PA_444AVS_PA",
                                       kernel));

  // Declares and initializes sampler8x8 state descriptor
  CM_SAMPLER_8X8_DESCR sampler_state_descr;
  CM_AVS_STATE_MSG avs_state_msg;
  memset(&avs_state_msg, 0, sizeof(CM_AVS_STATE_MSG));
  sampler_state_descr.avs = &avs_state_msg;
  CM_AVS_NONPIPLINED_STATE avs_state;
  memset(&avs_state, 0, sizeof(CM_AVS_NONPIPLINED_STATE));
  sampler_state_descr.avs->AvsState = &avs_state;

  // Configures sampler state descriptor
  sampler_state_descr.stateType = CM_SAMPLER8X8_AVS;
  sampler_state_descr.avs->AVSTYPE = 0;                      // Adaptive
  sampler_state_descr.avs->BypassIEF = 1;
  sampler_state_descr.avs->EightTapAFEnable = 0x00;
  sampler_state_descr.avs->GainFactor = 44;                  // default
  sampler_state_descr.avs->GlobalNoiseEstm = 255;            // default
  sampler_state_descr.avs->StrongEdgeThr = 8;                // default
  sampler_state_descr.avs->WeakEdgeThr = 1;                  // default
  sampler_state_descr.avs->StrongEdgeWght = 7;               // default
  sampler_state_descr.avs->RegularWght = 2;                  // default
  sampler_state_descr.avs->NonEdgeWght = 1;                  // default
  sampler_state_descr.avs->wR3xCoefficient = 6;
  sampler_state_descr.avs->wR3cCoefficient = 15;
  sampler_state_descr.avs->wR5xCoefficient = 9;
  sampler_state_descr.avs->wR5cxCoefficient = 8;
  sampler_state_descr.avs->wR5cCoefficient = 3;
  sampler_state_descr.avs->AvsState->BypassXAF = 0;  // Disables X filtering
  sampler_state_descr.avs->AvsState->BypassYAF = 0;  // Disables Y filtering
  sampler_state_descr.avs->AvsState->maxDerivative4Pixels = 7;
  sampler_state_descr.avs->AvsState->maxDerivative8Pixels = 20;
  sampler_state_descr.avs->AvsState->transitionArea4Pixels = 4;
  sampler_state_descr.avs->AvsState->transitionArea8Pixels = 5;
  sampler_state_descr.avs->AvsState->DefaultSharpLvl = 255;

  // AVS coefficients
  for (int i = 0; i < CM_NUM_COEFF_ROWS; i++)  {
  // Y horizontal
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_0 = Tbl0X[i][0];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_1 = Tbl0X[i][1];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_2 = Tbl0X[i][2];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_3 = Tbl0X[i][3];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_4 = Tbl0X[i][4];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_5 = Tbl0X[i][5];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_6 = Tbl0X[i][6];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_7 = Tbl0X[i][7];
    // Y vertical
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_0 = Tbl0Y[i][0];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_1 = Tbl0Y[i][1];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_2 = Tbl0Y[i][2];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_3 = Tbl0Y[i][3];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_4 = Tbl0Y[i][4];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_5 = Tbl0Y[i][5];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_6 = Tbl0Y[i][6];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_7 = Tbl0Y[i][7];
    // UV horizontal
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_0 = Tbl1X[i][0];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_1 = Tbl1X[i][1];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_2 = Tbl1X[i][2];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_3 = Tbl1X[i][3];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_4 = Tbl1X[i][4];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_5 = Tbl1X[i][5];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_6 = Tbl1X[i][6];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_7 = Tbl1X[i][7];
    // UV vertical
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_0 = Tbl1Y[i][0];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_1 = Tbl1Y[i][1];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_2 = Tbl1Y[i][2];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_3 = Tbl1Y[i][3];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_4 = Tbl1Y[i][4];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_5 = Tbl1Y[i][5];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_6 = Tbl1Y[i][6];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_7 = Tbl1Y[i][7];
  }

  // Gets GPU platform information
  GPU_PLATFORM platform;
  size_t cap_size = sizeof(platform);
  device->GetCaps(CAP_GPU_PLATFORM, cap_size, &platform);

  // Initilizes filter, additionally for Skylake+ system
  if (platform >= PLATFORM_INTEL_SKL) {
    for (int i = CM_NUM_COEFF_ROWS; i < CM_NUM_COEFF_ROWS_SKL; i++) {
      // Y horizontal
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_0 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_1 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_2 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_3 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_4 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_5 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_6 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_7 = 0.125f;
      // Y vertical
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_0 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_1 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_2 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_3 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_4 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_5 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_6 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_7 = 0.125f;
      // UV horizontal
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_0 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_1 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_2 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_3 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_4 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_5 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_6 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_7 = 0.125f;
      // UV vertical
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_0 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_1 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_2 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_3 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_4 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_5 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_6 = 0.125f;
      sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_7 = 0.125f;
    }
  }

  // Creates sampler state sampler8x8, using sampler state descrepter
  // sampler_state_descr
  CmSampler8x8 *sampler8x8 = nullptr;
  cm_result_check(device->CreateSampler8x8(sampler_state_descr, sampler8x8));

  // Creates input surface with given width and height in pixels and format.
  // Sets surface format as CM_SURFACE_FORMAT_UYVY.
  CmSurface2D *input_surf = nullptr;
  cm_result_check(device->CreateSurface2D(frame_width,
                                          frame_height,
                                          CM_SURFACE_FORMAT_UYVY,
                                          input_surf));

  // Creates a 2D surface for output, with given width and height and surface
  // format CM_SURFACE_FORMAT_YUY2
  CmSurface2D *output_surf = nullptr;
  cm_result_check(device->CreateSurface2D(out_frame_width,
                                          out_frame_height,
                                          CM_SURFACE_FORMAT_YUY2,
                                          output_surf));

  // Copies system memory content to the input surface using the CPU. The
  // system memory content is the data of the input image. The size of data
  // copied is the size of data in the surface.
  cm_result_check(input_surf->WriteSurface(input_buffer, nullptr));

  // Finds number of threads based on frame size in pixel,
  // for this case, frame size 64x32, block size is 16x4 pixels.
  int threadswidth  = frame_width / block_width / 4;
  int threadsheight = frame_height / block_height * 3 / 2;

  // Creates a CmThreadSpace object to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution.
  CmThreadSpace *ts = nullptr;
  cm_result_check(device->CreateThreadSpace(threadswidth, threadsheight, ts));

  // Gets sampler index for input surface
  SamplerIndex *pInputSamplerIndex = nullptr;
  sampler8x8->GetIndex(pInputSamplerIndex);

  // Sets sampler index as argument 0, the first argument
  kernel->SetKernelArg(0, sizeof(SamplerIndex), pInputSamplerIndex);

  // Gets sampler8x8 input surface index
  SurfaceIndex *index0 = nullptr;
  cm_result_check(device->CreateSampler8x8Surface(input_surf,
                                                  index0,
                                                  CM_AVS_SURFACE));

  // Sets input surface index as argument 1
  kernel->SetKernelArg(1, sizeof(SurfaceIndex),index0);

  // Gets output surface index
  SurfaceIndex *index1 = nullptr;
  output_surf->GetIndex(index1);

  // Sets output surface index as argument 2
  kernel->SetKernelArg(2, sizeof(SurfaceIndex), index1);

  // Sets argument 3 ~ 6.
  kernel->SetKernelArg(3, sizeof(block_width), &block_width);
  kernel->SetKernelArg(4, sizeof(block_height), &block_height);
  kernel->SetKernelArg(5, sizeof(frame_width), &frame_width);
  kernel->SetKernelArg(6, sizeof(frame_height), &frame_height);

  // Creates a task queue.
  // It is used to enqueue the kernels for execution.
  CmQueue *cm_queue = nullptr;
  cm_result_check(device->CreateQueue(cm_queue));

  // Creates a task to be put in the task queue.
  CmTask *kernel_array = nullptr;
  cm_result_check(device->CreateTask(kernel_array));

  // Adds a kernel to the task
  cm_result_check(kernel_array-> AddKernel(kernel));

  // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
  // function returns immediately without waiting for the GPU to start or
  // finish execution of the task. The runtime will query the HW status. If
  // the hardware is not busy, the runtime will submit the task to the
  // driver/HW; otherwise, the runtime will submit the task to the driver/HW
  // at another time.
  // An event, e, is created to track the status of the task.
  // ThreadSpace is an input and specified by the argument ts.
  CmEvent *e = nullptr;
  cm_result_check(cm_queue->Enqueue(kernel_array, e, ts));

  // Destroys a CmTask object.
  // CmTask will be destroyed when CmDevice is destroyed.
  // Here, the application destroys the CmTask object by itself.
  device->DestroyTask(kernel_array);

  // Reads the output surface content to the system memory using the CPU.
  // The size of data copied is the size of data in Surface.
  // It is a blocking call. The function will not return until the copy
  // operation is completed.
  // The dependent event e ensures that the reading of the surface
  // will not happen until its state becomes CM_STATUS_FINISHED.
  cm_result_check(output_surf->ReadSurface(output_buffer, e));

  // Reads gold_file, matches the output image
  // and prints mismatch error.
  bool mismatch = false;
  int ind;
  if (fread(golden_buffer, 1, golden_file_size, golden_file_handle)
      != golden_file_size) {
    perror("Error reading Golden output file");
    delete_buffers(input_buffer, output_buffer, golden_buffer);
    return -1;
  } else {
    for (int l = 0; l < out_frame_height; l++) {
      for (int m = 0 ; m < out_frame_width*out_frame_factor; m++) {
        ind = static_cast<int>(m + l * out_frame_width*out_frame_factor);
        if (golden_buffer[ind] != output_buffer[ind]) {
          printf("G(%d,%d) = %d ; O(%d,%d) = %d, result mismatched\n", l, m,
              golden_buffer[ind], l, m, output_buffer[ind]);
          mismatch = true;
          break;
        }
      }
    }
  }

  // Gets and prints the execution time
  UINT64  execution_time = 0;
  cm_result_check(e->GetExecutionTime(execution_time));

  // Outputs the execution time
  printf("Kernel execution time is:\n");
  printf("\t\t\t %llu nanoseconds\n", execution_time);
  printf("\t\t\t %8.2f microseconds\n", execution_time/1000.0);
  printf("\t\t\t %8.2f milliseconds\n\n", execution_time/1000000.0);

  // Writes a output frame to output file
  if (fwrite(output_buffer, sizeof(char), out_frame_size, output_file_handle)
      != out_frame_size) {
    printf("Unable to write a frame of data.");
    delete_buffers(input_buffer, output_buffer, golden_buffer);
    fcloseall();
    return -1;
  }
  fclose(output_file_handle);

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  cm_result_check(::DestroyCmDevice(device));

  // Deletes memory
  delete_buffers(input_buffer, output_buffer, golden_buffer);

  // Prints the final result
  if (mismatch) {
    printf("CM result is inconsistent with Golden\n");
    return -1;
  } else {
    printf("Pass, CM result is consistent with Golden\n");
    return 0;
  }
}
