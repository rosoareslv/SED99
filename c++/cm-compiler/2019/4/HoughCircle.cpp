/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

// c++ string
#include <string>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"

// Includes bitmap_helpers.h for bitmap file open/save/compare operations.
#include "../common/bitmap_helpers.h"

// Include cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "../common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "../common/isa_helpers.h"
#include <algorithm>
#include <time.h>
#include <iostream>
#include "HoughCircle.h"

using namespace std;

void
cmk_hough_circle_acc(SurfaceIndex input,      // edge pixels image
                     SurfaceIndex output,     // hough circle accumulator counts
                     unsigned int img_height, // edge pixel image's height
                     unsigned int img_width,  // edge pixel image's width
                     unsigned int radius); // radius of circle we are detecting

bool validate_hough_circle(unsigned int *hough_cnt, unsigned int height,
                           unsigned int width, unsigned int pitch_elems) {
  // expected result
  FILE *res = fopen("hough_circle_res.dat", "rb");
  if (res == NULL) {
    perror("hough_circle_res.dat");
    return false;
  }

  unsigned int *expect_cnt = new unsigned int[height * width];
  fread(expect_cnt, 1, height * width * sizeof(unsigned int), res);

  bool pass = true;
  for (int i = 0; i < height; i++) {
    if (memcmp(&hough_cnt[i * pitch_elems], &expect_cnt[i * width],
               width * sizeof(unsigned int))) {
      pass = false;
      break;
    }
  }

  delete expect_cnt;
  return pass;
}

int main(int argc, char *argv[]) {

  int result;

  FILE *in;

  unsigned int width = 0;
  unsigned int height = 0;
  unsigned char header[54];

  in = fopen("pen_circle_edges.bmp", "rb");
  if (in == NULL) {
    perror("pen_circle_edges.bmp");
    return -1;
  }
  if (fread(header, 1, 54, in) != 54) {
    perror("pen_circle_edges.bmp");
    return -1;
  }

  width = *(short *)&header[18];
  height = *(short *)&header[22];
  int pixel_array_off = *(int *)&header[10];
  unsigned ncolors = *(int *)&header[46];
  fseek(in, pixel_array_off, SEEK_SET);

  cout << "Input Edges size WxH " << width << " x " << height << endl;

  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));

  // Gets necessary information in order to create and use CmSurface2DUP as
  // input surface later.
  // To create CmSurface2DUP, user needs to allocate such amount of system
  // memory which is equal to or larger than physical size returned here.
  // When accessing the system memory, user needs to be aware of the pitch,
  // which is equal to pixel_width * byte_per_pixel + necessary_padding.
  unsigned int pitch_size = 0;
  unsigned int surface_size = 0;
  cm_result_check(device->GetSurface2DInfo(width, height, CM_SURFACE_FORMAT_A8,
                                           pitch_size, surface_size));

  // Creates a CmSurface2DUP as input surface in UP (User Provided) system
  // memory
  // with given surface width and height in pixel, and format. The UP system
  // memory
  // must be page (4K Bytes) aligned. The size of the system memory must be
  // larger than or equal to the size returned by GetSurface2DInfo.
  // Application can either access the memory through the memory pointer from
  // the CPU, or access the 2D surface created upon the same memory from the
  // GPU.
  CmSurface2DUP *input_surface = nullptr;
  unsigned char *edges =
      (unsigned char *)CM_ALIGNED_MALLOC(surface_size, 0x1000);
  memset(edges, 0, surface_size);
  //
  // reads in edges
  //
  int padding = (4 - width % 4);
  for (int i = height - 1; i >= 0; i--) {
    if (fread(&edges[i * pitch_size], 1, width, in) != width) {
      perror("pen_circle_edges.bmp");
      return -1;
    }
    // skip padding
    char dummy[4];
    if (width % 4 != 0)
      fread(dummy, 1, padding, in);
  }
  cm_result_check(device->CreateSurface2DUP(width, height, CM_SURFACE_FORMAT_A8,
                                            edges, input_surface));
  // create output surface for hough circle count
  cm_result_check(device->GetSurface2DInfo(
      width, height, CM_SURFACE_FORMAT_R32F, pitch_size, surface_size));
  cout << "pitch size " << pitch_size << endl;
  // number of elements per pitch
  int pitch_elems = pitch_size / sizeof(unsigned int);
  CmSurface2DUP *output_surface = nullptr;
  unsigned int *hough_cnt = (unsigned int *)CM_ALIGNED_MALLOC(
      surface_size, 0x1000); // same size as input
  memset(hough_cnt, 0, surface_size);
  cm_result_check(device->CreateSurface2DUP(
      width, height, CM_SURFACE_FORMAT_R32F, hough_cnt, output_surface));

  // load kernel file
  std::string isa_code = cm::util::isa::loadFile("HoughCircle_genx.isa");
  if (isa_code.size() == 0) {
    std::cerr << "Error: empty ISA binary.\n";
    exit(1);
  }
  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                      isa_code.size(), program));
  // Creates the Hough Circle kernel.
  CmKernel *hough_circle_kernel = nullptr;
  cm_result_check(device->CreateKernel(
      program, CM_KERNEL_FUNCTION(cmk_hough_circle_acc), hough_circle_kernel));
  // determine how many threads we need
  // each thread handling 8x8 pixels
  // Some threads may not process 8x8 if the image size that is not divisable by
  // 8,
  unsigned int ts_width = (width + BLK_W - 1) / BLK_W;
  unsigned int ts_height = (height + BLK_H - 1) / BLK_H;
  unsigned int total_threads = ts_width * ts_height;
  // When a surface is created by the CmDevice a SurfaceIndex object is
  // created. This object contains a unique index value that is mapped to the
  // surface.
  // Gets the input surface index.
  SurfaceIndex *input_idx = nullptr;
  cm_result_check(input_surface->GetIndex(input_idx));
  SurfaceIndex *output_idx = nullptr;
  cm_result_check(output_surface->GetIndex(output_idx));
  
  // Creates a CmThreadSpace object.
  CmThreadSpace *thread_space = nullptr;
  cm_result_check(device->CreateThreadSpace(ts_width, ts_height, thread_space));
  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued.
  CmQueue *cmd_queue = nullptr;
  cm_result_check(device->CreateQueue(cmd_queue));

  // set kernel arguments
  unsigned int radius = 20;
  cm_result_check(
      hough_circle_kernel->SetKernelArg(0, sizeof(SurfaceIndex), input_idx));
  cm_result_check(
      hough_circle_kernel->SetKernelArg(1, sizeof(SurfaceIndex), output_idx));
  cm_result_check(
      hough_circle_kernel->SetKernelArg(2, sizeof(unsigned int), &height));
  cm_result_check(
      hough_circle_kernel->SetKernelArg(3, sizeof(unsigned int), &width));
  cm_result_check(
      hough_circle_kernel->SetKernelArg(4, sizeof(unsigned int), &radius));

  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *hough_task = nullptr;
  cm_result_check(device->CreateTask(hough_task));
  // This task has one kernel, "cmk_radix_count".
  cm_result_check(hough_task->AddKernel(hough_circle_kernel));

  cout << "Hough Circle Start..." << endl;

  clock_t start = clock(); // start timer
  // execute hough kernel
  CmEvent *event = nullptr;
  cm_result_check(cmd_queue->Enqueue(hough_task, event, thread_space));
  // Waits for the task associated with "sync_event" finishing execution
  // on the GPU.
  unsigned long time_out = -1;
  cm_result_check(event->WaitForTaskFinished(time_out));

  clock_t end = clock(); // end timer
  cout << " Hough Circle Time = " << end - start << " msec " << endl;

  bool passed = validate_hough_circle(hough_cnt, height, width, pitch_elems);

  // general header
  unsigned char GH[14] = {'B', 'M', 0, 0, 0, 0, 0, 0, 0, 0, 54, 0, 0, 0};
  // info header
  unsigned char DH[40] = {40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                          32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

  // + 3 to consider padding
  // unsigned rowSz = ((width * 3 + 3) >> 2) << 2;

  unsigned rowSz = width * sizeof(int);
  unsigned int pixelArraySz = height * rowSz;
  // compute file size
  unsigned int fileSz = pixelArraySz + 54;
  *((unsigned int *)&GH[2]) = fileSz;
  // set width and height
  *((unsigned int *)&DH[4]) = width;
  *((unsigned int *)&DH[8]) = height;

  FILE *out = fopen("hough_circle_acc.bmp", "wb");
  if (out == NULL) {
    perror("hough_circle_acc.bmp");
    return -1;
  }

  // set pixel color values
  unsigned cnt = 0;
  for (int i = 0; i < height; i++)
    for (int j = 0; j < width; j++) {
      if (hough_cnt[i * pitch_elems + j] > 0) {
        char t = hough_cnt[i * pitch_elems + j];
        // set R & G color accordingly
        hough_cnt[i * pitch_elems + j] |= (t << 16 | t << 8);
      }
    }

  // Write headers
  fwrite(GH, 1, sizeof(GH), out);
  fwrite(DH, 1, sizeof(DH), out);
  // bmp pixel layout:
  // first row is at the bottom. need to write last row first
  for (int i = height - 1; i >= 0; i--) {
    fwrite(&hough_cnt[i * pitch_elems], 1, rowSz, out);
  }

  fclose(out);

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, and the queue that were created
  // using this device instance that haven't explicitly been destroyed by
  // calling respective destroy functions.
  cm_result_check(::DestroyCmDevice(device));

  // Frees memory.
  CM_ALIGNED_FREE(edges);
  CM_ALIGNED_FREE(hough_cnt);

  std::cout << (passed ? "PASSED" : "FAILED") << std::endl;
  return (passed ? 0 : -1);
}
