/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <iostream>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"

// Include cm_rt_helpers.h to convert the integer return code
// returned from the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Include isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

// Include printf_check_results.h to verify the printf output is as expected.
#include "printf_check_results.h"

using namespace cm::util;

int main(int argc, char* argv[]) {
  // This program shows the usage of printf within the kernel.

  // Creates a CmDevice from scratch.
  // Param device:  pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *p_cm_device = nullptr;
  unsigned int version  = 0;
  cm_result_check(::CreateCmDevice(p_cm_device, version));

  // The file hello_world_genx.isa is generated when the kernel
  // in the file hello_world_genx.cpp is compiled by the CM compiler.
  // Reads the virtual ISA from "hello_world_genx.isa" to the code buffer.
  std::string isa_code = isa::loadFile("hello_world_genx.isa");
  if (isa_code.size() == 0) {
      std::cerr << "Error: empty ISA binary.\n";
      exit(1);
  }

  // Creates a CmProgram object consisting of the kernel loaded
  // from the code buffer
  CmProgram *p_program = nullptr;
  cm_result_check(p_cm_device->LoadProgram(const_cast<char* >(isa_code.data()),
                                           isa_code.size(),
                                           p_program));
  // Creates the hello_world kernel.
  // Param program:       CM program from which the kernel is created.
  // Param "hello_world": The kernel name which should be no more than
  // 256 bytes including the null terminator.
  CmKernel *p_kernel = nullptr;
  cm_result_check(p_cm_device->CreateKernel(p_program,
                                           "hello_world",
                                            p_kernel));

  // Each CmKernel can be executed by multiple concurrent threads.
  // We will arbitrarily use an 8x8 block for a total of 64 threads.
  int thread_width  = 8;
  int thread_height = 8;

  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during kernel
  // execution. For this example, we use the latter usage model.
  CmThreadSpace *p_thread_space = nullptr;
  cm_result_check(p_cm_device->CreateThreadSpace(thread_width,
                                                 thread_height,
                                                 p_thread_space));

  // Sets a per kernel argument.
  // Here we will pass the thread space width to the kernel in order
  // to convert the thread coordinates to a linearized thread ID for printing.
  cm_result_check(p_kernel->SetKernelArg(0,
                                         sizeof(thread_width),
                                         &thread_width));

  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers.
  // It is used to enqueue the kernels for execution.
  CmTask *p_task = nullptr;
  cm_result_check(p_cm_device->CreateTask(p_task));

  // Adds a CmKernel pointer to CmTask.
  cm_result_check(p_task->AddKernel(p_kernel));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  CmQueue *p_queue = nullptr;
  cm_result_check(p_cm_device->CreateQueue(p_queue));

  // Inits the print buffer.
  // Here the buffer used by printf is allocated.
  cm_result_check(p_cm_device->InitPrintBuffer());

  // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
  // function returns immediately without waiting for the GPU to start or
  // finish execution of the task. The runtime will query the HW status. If
  // the hardware is not busy, the runtime will submit the task to the
  // driver/HW; otherwise, the runtime will submit the task to the driver/HW
  // at another time.
  // An event, "p_event", is created to track the status of the task.
  CmEvent *p_event = nullptr;
  cm_result_check(p_queue->Enqueue(p_task, p_event, p_thread_space));

  // Waits for the task to finish.
  // Here we use the task event to ensure the task has completed on the GPU
  // before flushing the print buffer.
  // The default timeout period is 2 seconds. We can specify a longer or
  // shorter timeout period in milliseconds by passing an argument
  // to this function. In this case, we use the default timeout period.
  cm_result_check(p_event->WaitForTaskFinished());

  // Flushes the print buffer to stdout.
  // This function call will also clear/reset the print buffer.
  cm_result_check(p_cm_device->FlushPrintBuffer());

  // Destroys the CmEvent.
  // The CmEvent must be destroyed by the user explicitly.
  cm_result_check(p_queue->DestroyEvent(p_event));

  // To verify the printf results, we run the kernel again;
  // this time we will dump the print buffer output to a file in order
  // to compare the actual results with the expected results.
  // The kernel is still in the task so we will just call Enqueue again.
  // To remove the kernel(s) from the task, call CmTask::Reset().
  CmEvent *p_new_event = nullptr;
  cm_result_check(p_queue->Enqueue(p_task, p_new_event, p_thread_space));

  // Waits for the task to finish.
  cm_result_check(p_new_event->WaitForTaskFinished());

  // Flushes the print buffer to a file named "hello_world_output.txt".
  const char *filename = "hello_world_output.txt";
  cm_result_check(p_cm_device->FlushPrintBufferIntoFile(filename));

  // Destroys the CmEvent.
  // The CmEvent must be destroyed by the user explicitly.
  cm_result_check(p_queue->DestroyEvent(p_new_event));

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  cm_result_check(::DestroyCmDevice(p_cm_device));

  // Checks the printf results
  bool passed = CheckPrintfResults(filename);

  if (passed)
      printf("PASSED\n");
  else
      printf("FAILED\n");

  return (passed ? 0 : -1);
}
