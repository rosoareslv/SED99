/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"

// Includes bitmap_helpers.h for bitmap file open/save operations.
#include "common/bitmap_helpers.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

// Y Horizontal Table
float tbl0x[17][8] = {
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
};

// Y Vertical Table
float tbl0y[17][8] = {
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
};

// UV Horizontal Table
float tbl1x[17][8] = {
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
};
// UV Vertical Table
float tbl1y[17][8] = {
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
  { 0.000000,0.000000,0.000000,1.000000,0.000000,0.000000,0.000000,0.000000},
};

int main(int argc, char *argv[]) {
  // This program shows the usage of hardware media sampler in the adaptive
  // filter application. The host side is responsible to configure the sampler
  // descriptor to decide the filter states, and filter coefficients etc, and
  // on the GPU kernel, the sampler messages are sent to media sampler
  // to do the sampling work, it will process 16x4 block for each sampler
  // message. The result will be written to the output surface, host side
  // will read it out, and compare with golden image.

  // Inputs source image file, output image file and golden image file
  char *input_file = "source.yuy2";
  char *output_file = "source_out.yuy2";
  char *gold_file = "avs_nearest_422_001.fs.yuy2";

  // Opens input file
  FILE *input_filehandle = fopen(input_file, "rb");
  if (input_filehandle == NULL) {
    printf("Error opening %s\n", input_file);
    fcloseall();
    exit(1);
  }

  // Opens output file
  FILE *output_filehandle = fopen(output_file, "wb");
  if (output_filehandle == NULL) {
    printf("Error opening %s\n", output_file);
    fcloseall();
    exit(1);
  }

  // opens Golden data file
  FILE *golden_file_handle = fopen(gold_file, "rb");
  if (golden_file_handle == nullptr) {
      perror("Error openning golden output file");
      fcloseall();
      exit(1);
  }

  int block_width = 16;
  int block_height = 4;

  int frame_width = 64;
  int frame_height = 32;
  int outframe_width = 64;
  int outframe_height = 32;
  float frame_factor = 2.0f;
  float outframe_factor = 2.0f;

  // Allocates memory
  int frame_size = static_cast<int>(frame_width *
      frame_height * frame_factor);
  unsigned char *input_buffer =  new unsigned char[frame_size];
  unsigned char *output_buffer = new unsigned char[frame_size];

  if (!input_buffer || !output_buffer) {
    fclose(input_filehandle);
    fclose(output_filehandle);
    fclose(golden_file_handle);
    printf("Allocate memory fail!\n");
    exit(1);
  }

  // Reads a frame of YUY2 data
  if (fread(input_buffer, sizeof(char), frame_size, input_filehandle)
      != frame_size) {
    printf("Unable to read a frame of data.");
    return -1;
  }
  fclose(input_filehandle);

  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));

  // The file avs_nearest_422_001_16x4_genx.isa is generated from kernel
  // in the file. avs_nearest_422_001_16x4_genx.cpp are compiled by the
  // CM compiler. There is one kernel included here, PA_444AVS_PA.
  // Reads in the virtual ISA from "multi_kerneles_genx.isa" to the code
  // buffer.
  std::string isa_code = cm::util::isa::loadFile
      ("avs_nearest_422_001_16x4_genx.isa");
  if (isa_code.size() == 0) {
      fcloseall();
      delete[] input_buffer;
      delete[] output_buffer;
    std::cerr << "Error: empty ISA binary.\n";
    exit(1);
  }

  // Creates a CmProgram object consisting of the kernels loaded from
  // the code buffer.
  // Param isa_code.data(): Pointer to the code buffer containing
  // the virtual ISA.
  // Param isa_code.size(): Size in bytes of the code buffer
  // containing the virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                      isa_code.size(),
                                      program));

  // Creates the PA_444AVS_PA kernel.
  // Param program: CM Program from which the kernel is created.
  // Param "PA_444AVS_PA": The kernel name which should be no more
  // than 256 bytes including the null terminator.
  CmKernel *kernel_sampler = nullptr;
  cm_result_check(device->CreateKernel(program,
                                       "PA_444AVS_PA",
                                       kernel_sampler));

  // Defines sampler8x8 state
  CM_SAMPLER_8X8_DESCR sampler_state_descr;
  CM_AVS_STATE_MSG avs_state_msg;
  memset(&avs_state_msg, 0, sizeof(CM_AVS_STATE_MSG));
  sampler_state_descr.avs = &avs_state_msg;
  CM_AVS_NONPIPLINED_STATE avs_state;
  memset(&avs_state, 0, sizeof(CM_AVS_NONPIPLINED_STATE));
  sampler_state_descr.avs->AvsState = &avs_state;

  // configs AVS descriptor parameters
  sampler_state_descr.stateType = CM_SAMPLER8X8_AVS;
  sampler_state_descr.avs->AVSTYPE = 0;
  sampler_state_descr.avs->BypassIEF = 1;
  // 01: Enable 8-tap Adaptive filter on G-channel. 4-tap filter on
  // other channels.
  sampler_state_descr.avs->EightTapAFEnable = 0x01;
  sampler_state_descr.avs->GainFactor = 44;
  sampler_state_descr.avs->GlobalNoiseEstm = 255;
  sampler_state_descr.avs->StrongEdgeThr = 8;
  sampler_state_descr.avs->WeakEdgeThr = 1;
  sampler_state_descr.avs->StrongEdgeWght = 7;
  sampler_state_descr.avs->RegularWght = 2;
  sampler_state_descr.avs->NonEdgeWght = 1;
  sampler_state_descr.avs->wR3xCoefficient = 6;
  sampler_state_descr.avs->wR3cCoefficient = 15;
  sampler_state_descr.avs->wR5xCoefficient = 9;
  sampler_state_descr.avs->wR5cxCoefficient = 8;
  sampler_state_descr.avs->wR5cCoefficient = 3;
  sampler_state_descr.avs->AvsState->BypassXAF = 1;
  sampler_state_descr.avs->AvsState->BypassYAF = 1;
  sampler_state_descr.avs->AvsState->DefaultSharpLvl = 255;
  // AVS coefficients
  for (int i = 0; i < CM_NUM_COEFF_ROWS; i++)  {
    // Y horizontal
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_0 = tbl0x[i][0];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_1 = tbl0x[i][1];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_2 = tbl0x[i][2];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_3 = tbl0x[i][3];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_4 = tbl0x[i][4];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_5 = tbl0x[i][5];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_6 = tbl0x[i][6];
    sampler_state_descr.avs->AvsState->Tbl0X[i].FilterCoeff_0_7 = tbl0x[i][7];
    // Y vertical
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_0 = tbl0y[i][0];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_1 = tbl0y[i][1];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_2 = tbl0y[i][2];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_3 = tbl0y[i][3];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_4 = tbl0y[i][4];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_5 = tbl0y[i][5];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_6 = tbl0y[i][6];
    sampler_state_descr.avs->AvsState->Tbl0Y[i].FilterCoeff_0_7 = tbl0y[i][7];
    // UV horizontal
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_0 = tbl1x[i][0];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_1 = tbl1x[i][1];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_2 = tbl1x[i][2];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_3 = tbl1x[i][3];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_4 = tbl1x[i][4];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_5 = tbl1x[i][5];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_6 = tbl1x[i][6];
    sampler_state_descr.avs->AvsState->Tbl1X[i].FilterCoeff_0_7 = tbl1x[i][7];
    // UV vertical
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_0 = tbl1y[i][0];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_1 = tbl1y[i][1];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_2 = tbl1y[i][2];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_3 = tbl1y[i][3];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_4 = tbl1y[i][4];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_5 = tbl1y[i][5];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_6 = tbl1y[i][6];
    sampler_state_descr.avs->AvsState->Tbl1Y[i].FilterCoeff_0_7 = tbl1y[i][7];
  }

  // Creates sampler state using sampler state descrepter
  CmSampler8x8 *psampler8x8 = nullptr;
  cm_result_check(device->CreateSampler8x8(sampler_state_descr, psampler8x8));

  // Creates a 2D surface for input image with specified width, height
  // and format
  CmSurface2D *input_surface = nullptr;
  cm_result_check(device->CreateSurface2D(frame_width,
                                          frame_height,
                                          CM_SURFACE_FORMAT_YUY2,
                                          input_surface));

  // Creates the output surface. The width, height and format is the same as
  // the input surface.
  CmSurface2D *output_surface = nullptr;
  cm_result_check(device->CreateSurface2D(frame_width,
                                          frame_height,
                                          CM_SURFACE_FORMAT_YUY2,
                                          output_surface));

  // Copies system memory content to the input surface using the CPU. The
  // system memory content is the data of the input image. The size of data
  // copied is the size of data in the surface.
  cm_result_check(input_surface->WriteSurface(input_buffer,
                                              nullptr));

  // Each CmKernel can be executed by multiple concurrent threads.
  // Here,for "PA_444AVS_PA" kernel, each thread works on a block of 16x4
  // pixels.The thread width is equal to input image width divided by 16.
  // The thread height is equal to input image height divided by 4.
  int thread_width = frame_width / block_width;
  int thread_height = frame_height / block_height;

  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution. For this example, we use the latter usage model.
  CmThreadSpace *thread_space_sampler = nullptr;
  cm_result_check(device->CreateThreadSpace(thread_width,
                                            thread_height,
                                            thread_space_sampler));

  // Gets sampler index for input surface
  SamplerIndex *input_Sampler_index = nullptr;
  cm_result_check(psampler8x8->GetIndex(input_Sampler_index));

  // Gets sampler8x8 input surface index
  SurfaceIndex *index0 = nullptr;
  cm_result_check(device->CreateSampler8x8Surface(input_surface,
                                                  index0,
                                                  CM_AVS_SURFACE));

  // Sets sampler index as first parameter for kernel "PA_444AVS_PA"
  cm_result_check(kernel_sampler->SetKernelArg(0,
                                               sizeof(SamplerIndex),
                                               input_Sampler_index));

  // Sets input surface index as second parameter for kernel "PA_444AVS_PA"
  cm_result_check(kernel_sampler->SetKernelArg(1,
                                               sizeof(SurfaceIndex),
                                               index0));

  // Gets output surface index
  SurfaceIndex *output_surface_idx = nullptr;
  cm_result_check(output_surface->GetIndex(output_surface_idx));

  // Sets output surface index as third parameter for kernel "PA_444AVS_PA"
  cm_result_check(kernel_sampler->SetKernelArg(2,
                                               sizeof(SurfaceIndex),
                                               output_surface_idx));

  // Sets Block width as 4th parameter of kernel "PA_444AVS_PA"
  cm_result_check(kernel_sampler->SetKernelArg(3,
                                               sizeof(block_width),
                                               &block_width));

  // Sets Block height as 5th parameter of kernel "PA_444AVS_PA"
  cm_result_check(kernel_sampler->SetKernelArg(4,
                                               sizeof(block_height),
                                               &block_height));

  // Sets input surface width as 6th parameter of kernel "PA_444AVS_PA"
  cm_result_check(kernel_sampler->SetKernelArg(5,
                                               sizeof(frame_width),
                                               &frame_width));

  // Sets input surface height as 7th parameter of kernel "PA_444AVS_PA"
  cm_result_check(kernel_sampler->SetKernelArg(6,
                                               sizeof(frame_height),
                                               &frame_height));
  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  CmQueue *queue = nullptr;
  cm_result_check(device->CreateQueue(queue));

  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *task = nullptr;
  cm_result_check(device->CreateTask(task));

  // Adds a CmKernel pointer to CmTask.
  cm_result_check(task->AddKernel(kernel_sampler));

  // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
  // function returns immediately without waiting for the GPU to start or
  // finish execution of the task. The runtime will query the HW status. If
  // the hardware is not busy, the runtime will submit the task to the
  // driver/HW; otherwise, the runtime will submit the task to the driver/HW
  // at another time.
  // An event, "sync_event", is created to track the status of the task.
  CmEvent *sync_event = nullptr;
  cm_result_check(queue->Enqueue(task, sync_event, thread_space_sampler));

  // Destroys a CmTask object.
  // CmTask will be destroyed when CmDevice is destroyed.
  // Here, the application destroys the CmTask object by itself.
  cm_result_check(device->DestroyTask(task));

  // Reads the output surface content to the system memory using the CPU.
  // The size of data copied is the size of data in Surface.
  // It is a blocking call. The function will not return until the copy
  // operation is completed.
  // The dependent event "sync_event" ensures that the reading of the surface
  // will not happen until its state becomes CM_STATUS_FINISHED.
  cm_result_check(output_surface->ReadSurface(output_buffer,
                                              sync_event));

  // Finds the Golden file size
  fseek(golden_file_handle, 0, SEEK_END);
  int golden_file_size = ftell(golden_file_handle);
  rewind(golden_file_handle);

  if (golden_file_size == 0) {
    fcloseall();
    delete[] input_buffer;
    delete[] output_buffer;
    perror("golden_file_handle is 0");
    return -1;
  }

  // Reads Golden output file, compared with output data file, if there is any
  // pixel mismatch, return false, otherwise, it will true.
  unsigned char* golden_buffer = new unsigned char[golden_file_size];
  if (!golden_buffer) {
      perror("Failed allocate memeory for GoldenBuffer");
      fcloseall();
      delete[] input_buffer;
      delete[] output_buffer;
      return -1;
  }
  bool mismatch = false;
  int ind;
  if (fread(golden_buffer, 1, golden_file_size, golden_file_handle)
      != golden_file_size) {
    perror("Error reading Golden output file");
    return -1;
  } else {
    for (int l = 0; l < outframe_height; l++) {
      for (int m = 0; m < outframe_width*outframe_factor; m++) {
        ind = m + l*outframe_width*outframe_factor;
        if (golden_buffer[ind] != output_buffer[ind]) {
          printf("G(%d,%d) = %d ; O(%d,%d) = %d, result mismatched\n",
              l, m, golden_buffer[ind], l, m, output_buffer[ind]);
          mismatch = true;
          break;
        }
      }
    }
  }

  // Queries the execution time of a task in the unit of nanoseconds.
  // The execution time is measured from the time the task started
  // execution in the GPU to the time when the task finished
  // execution.
  UINT64 execution_time = 0;
  cm_result_check(sync_event->GetExecutionTime(execution_time));
  std::cout << "Kernel execution time is " << execution_time
      << " nanoseconds" << std::endl;

  // Destroys the CmEvent.
  // CmEvent must be destroyed by the user explicitly.
  cm_result_check(queue->DestroyEvent(sync_event));

  // Write a frame
  if (fwrite(output_buffer, sizeof(char), frame_size, output_filehandle)
      != frame_size) {
    printf("Unable to write a frame of data.");
    return -1;
  }
  fclose(output_filehandle);
  fclose(golden_file_handle);

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  cm_result_check(::DestroyCmDevice(device));

  delete[] input_buffer;
  delete[] output_buffer;
  delete[] golden_buffer;

  if (mismatch) {
    printf("CM result is inconsistent with Golden\n");
    return -1;
  } else {
    printf("CM result is consistent with Golden\n");
    return 0;
  }
}
