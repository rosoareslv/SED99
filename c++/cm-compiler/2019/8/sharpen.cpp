/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <cstdio>

// C++ string
#include <string>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"

// Includes bitmap_helpers.h for bitmap file open/save operations.
#include "common/bitmap_helpers.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

int main(int argc, char *argv[]) {
  // Fills the sharpen image filter parameters.
  float filter[2 * 4 + 1];
  filter[0] = 0.00000004f;
  filter[1] = 0.00005852f;
  filter[2] = 0.00961892f;
  filter[3] = 0.20539963f;
  filter[4] = 0.56984567f;
  filter[5] = 0.20539963f;
  filter[6] = 0.00961892f;
  filter[7] = 0.00005852f;
  filter[8] = 0.00000004f;

  // Loads an input image named "sharpen_in.bmp".
  auto input_image = cm::util::bitmap::BitMap::load("sharpen_in.bmp");

  // Gets the width and height of the input image.
  unsigned width = input_image.getWidth();
  unsigned height = input_image.getHeight();

  // Checks the value of width, height and bpp(bits per pixel) of the image.
  // Only images in 8-bit RGB format are supported.
  // Only images with width and height a multiple of 8 are supported.
  if ((width & 7) || (height & 7) || input_image.getBPP() != 24) {
    std::cerr << "Error: Only images in 8-bit RGB format with width and "
        << "height a multiple of 8 are supported.\n";
    std::exit(1);
  }

  // Copies input image to output except for the data.
  auto output_image = input_image;

  // Sets image size in bytes. There are a total of width*height pixels and
  // each pixel occupies (output_image.getBPP()/8) bytes.
  unsigned img_size = width * height * (output_image.getBPP() / 8);

  // Sets output to blank image.
  output_image.setData(new unsigned char[img_size]);

  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));

  // Creates input surface with given width and height in pixels and format.
  // Sets surface format as CM_SURFACE_FORMAT_A8R8G8B8. For this format, each
  // pixel occupies 32 bits.
  CmSurface2D *input_surface = nullptr;
  cm_result_check(device->CreateSurface2D(width * 3 / 4,
                                          height,
                                          CM_SURFACE_FORMAT_A8R8G8B8,
                                          input_surface));

  // Copies system memory content to the input surface using the CPU. The
  // system memory content is the data of the input image. The size of data
  // copied is the size of data in the surface.
  cm_result_check(input_surface->WriteSurface(input_image.getData(),
                                              nullptr));

  // Creates the output surface of the horizontal blur. The width, height and
  // format is the same as input surface.
  CmSurface2D *output_surface_hor = nullptr;
  cm_result_check(device->CreateSurface2D(width * 3 / 4,
                                          height,
                                          CM_SURFACE_FORMAT_A8R8G8B8,
                                          output_surface_hor));

  // Creates the output surface of the vertical blur. The width, height and
  // format is the same as input surface.
  CmSurface2D *output_surface_ver = nullptr;
  cm_result_check(device->CreateSurface2D(width * 3 / 4,
                                          height,
                                          CM_SURFACE_FORMAT_A8R8G8B8,
                                          output_surface_ver));

  // When a surface is created by the CmDevice a SurfaceIndex object is
  // created. This object contains a unique index value that is mapped to the
  // surface.
  // Gets the input surface index.
  SurfaceIndex *input_surface_idx = nullptr;
  cm_result_check(input_surface->GetIndex(input_surface_idx));

  // Gets the output surface index of the horizontal blur.
  SurfaceIndex *output_surface_h_idx = nullptr;
  cm_result_check(output_surface_hor->GetIndex(output_surface_h_idx));

  // Gets the output surface index of the vertical blur.
  SurfaceIndex *output_surface_v_idx = nullptr;
  cm_result_check(output_surface_ver->GetIndex(output_surface_v_idx));

  // The file sharpen_genx.isa is generated when the kernels in the file
  // sharpen_genx.cpp are compiled by the CM compiler. There are three
  // kernels included here, "horizontal_blur", "vertical_blur", "simple_USM".
  // Reads in the virtual ISA from "sharpen_genx.isa" to the code buffer.
  std::string isa_code = cm::util::isa::loadFile("sharpen_genx.isa");
  if (isa_code.size() == 0) {
    std::cerr << "Error: empty ISA binary.\n";
    exit(1);
  }

  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                      isa_code.size(),
                                      program));

  // Creates the horizontal_blur kernel.
  // Param program: CM Program from which the kernel is created.
  // Param "horizontal_blur": The kernel name which should be no more than 256
  // bytes including the null terminator.
  CmKernel *kernel_hor_blur = nullptr;
  cm_result_check(device->CreateKernel(program,
                                       "horizontal_blur",
                                       kernel_hor_blur));

  // Each CmKernel can be executed by multiple concurrent threads.
  // Here, for "horizontal_blur" kernel, each thread works on a block of
  // (width * 4) pixels.
  // The thread width is equal to 1.
  // The thread height is equal to input image height divided by 4.
  int thread_height = height / 4;

  // Sets a per kernel argument.
  // Sets input surface index as the first argument.
  // Sets output surface index of horizontal blur as the second argument.
  // Sets image width as the third argument.
  // Sets image filter parameters as the fourth argument.
  cm_result_check(kernel_hor_blur->SetKernelArg(0,
                                                sizeof(SurfaceIndex),
                                                input_surface_idx));
  cm_result_check(kernel_hor_blur->SetKernelArg(1,
                                                sizeof(SurfaceIndex),
                                                output_surface_h_idx));
  cm_result_check(kernel_hor_blur->SetKernelArg(2,
                                                sizeof(width),
                                                &width));
  cm_result_check(kernel_hor_blur->SetKernelArg(3,
                                                sizeof(filter),
                                                filter));

  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution. For this example, we use the latter usage model.
  CmThreadSpace *thread_space_hor = NULL;
  cm_result_check(device->CreateThreadSpace(1,
                                            thread_height,
                                            thread_space_hor));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  CmQueue *queue = nullptr;
  cm_result_check(device->CreateQueue(queue));

  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *task = nullptr;
  cm_result_check(device->CreateTask(task));

  // Adds a CmKernel pointer to CmTask.
  // This task has one kernel, "horizontal_blur".
  cm_result_check(task->AddKernel(kernel_hor_blur));

  // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
  // function returns immediately without waiting for the GPU to start or
  // finish execution of the task. The runtime will query the HW status. If
  // the hardware is not busy, the runtime will submit the task to the
  // driver/HW; otherwise, the runtime will submit the task to the driver/HW
  // at another time.
  // An event, "sync_event0", is created to track the status of the task.
  CmEvent *sync_event0 = nullptr;
  cm_result_check(queue->Enqueue(task, sync_event0, thread_space_hor));

  // Destroys a CmTask object.
  // Releases task to prevent leaking as a new task will be created later.
  cm_result_check(device->DestroyTask(task));

  // Creates the vertical blur kernel. The kernel name is "vertical_blur".
  CmKernel *kernel_ver_blur = nullptr;
  cm_result_check(device->CreateKernel(program,
                                       "vertical_blur",
                                       kernel_ver_blur));

  // For "vertical_blur" kernel, each thread works on a block of (4 * height)
  // pixels.
  // The thread width is equal to input image width divided by 4.
  // The thread heght is equal to 1.
  int threadswidth = width / 4;

  // Sets kernel arguments for vertical_blur kernel.
  // Sets output surface index of horizontal blur as the first argument.
  // Sets output surface index of vertical blur as the second argument.
  // Sets image height as the third argument.
  // Sets image filter parameters as the fourth argument.
  cm_result_check(kernel_ver_blur->SetKernelArg(0,
                                                sizeof(SurfaceIndex),
                                                output_surface_h_idx));
  cm_result_check(kernel_ver_blur->SetKernelArg(1,
                                                sizeof(SurfaceIndex),
                                                output_surface_v_idx));
  cm_result_check(kernel_ver_blur->SetKernelArg(2,
                                                sizeof(height),
                                                &height));
  cm_result_check(kernel_ver_blur->SetKernelArg(3,
                                                sizeof(filter),
                                                filter));

  // Create thread space for vertical_blur kernel .
  CmThreadSpace *thread_space_ver = NULL;
  device->CreateThreadSpace(threadswidth, 1, thread_space_ver);

  // Creates a new CmTask object.
  cm_result_check(device->CreateTask(task));

  // Adds vertical_blur kernel to this new CmTask.
  cm_result_check(task->AddKernel(kernel_ver_blur));

  // Launches this new task on GPU.
  // An event, "sync_event1", is created to track the status of the task.
  CmEvent *sync_event1 = nullptr;
  cm_result_check(queue->Enqueue(task, sync_event1, thread_space_ver));

  // Releases task to prevent leaking as a new task will be created later.
  cm_result_check(device->DestroyTask(task));

  // Creates the unsharpen mask kernel. The kernel name is "simple_USM".
  CmKernel *kernel_usm = nullptr;
  cm_result_check(device->CreateKernel(program,
                                       "simple_USM",
                                       kernel_usm));

  // For "simple_USM" kernel, each thread works on a block of (width * 4)
  // pixels.
  // Thread width is equal to 1.
  // Thread height is equal to input image height divided by 4.
  thread_height = height / 4;

  // Sets kernel arguments for unsharpen mask kernel.
  // Sets input surface index as the first argument.
  // Sets output surface index of vertical blur as the second argument.
  // Sets output surface index of horizontal blur as the third argument.
  // Sets image width as the fourth argument.
  // Sets light amount as fifth argument.
  // Sets dark amount as sixth argument.
  cm_result_check(kernel_usm->SetKernelArg(0,
                                           sizeof(SurfaceIndex),
                                           input_surface_idx));
  cm_result_check(kernel_usm->SetKernelArg(1,
                                           sizeof(SurfaceIndex),
                                           output_surface_v_idx));
  cm_result_check(kernel_usm->SetKernelArg(2,
                                           sizeof(SurfaceIndex),
                                           output_surface_h_idx));
  cm_result_check(kernel_usm->SetKernelArg(3,
                                           sizeof(width),
                                           &width));
  short light = static_cast<short>((128. / 100.) * 75);
  short dark = static_cast<short>((128. / 100.) * 75);
  cm_result_check(kernel_usm->SetKernelArg(4,
                                           sizeof(short),
                                           &light));
  cm_result_check(kernel_usm->SetKernelArg(5,
                                           sizeof(short),
                                           &dark));

  // Creates a new CmTask object.
  cm_result_check(device->CreateTask(task));

  // Adds unsharpen mask kernel to this new CmTask
  cm_result_check(task->AddKernel(kernel_usm));

  // Launches this new task on GPU.
  // An event, "sync_event2", is created to track the status of the task.
  CmEvent *sync_event2 = nullptr;
  cm_result_check(queue->Enqueue(task, sync_event2, thread_space_hor));

  // Destroys a CmTask object.
  // CmTask will be destroyed when CmDevice is destroyed.
  // Here, the application destroys the CmTask object by itself.
  cm_result_check(device->DestroyTask(task));

  // Output_surface_hor is the final output surface, which contains the final
  // result.
  // Therefore we need read the output surface content to the system memory
  // using the CPU. The size of data copied is the size of data in Surface.
  // It's a blocking call. the function will not return until the copy
  // operation is completed. The dependent event "sync_event2" makes sure that
  // surface reading will not happen until its state becomes
  // CM_STATUS_FINISHED.
  cm_result_check(output_surface_hor->ReadSurface(output_image.getData(),
                                                  sync_event2));

  // Queries the execution time of a task in the unit of nanoseconds.
  // The execution time is measured from the time the task started execution
  // in the GPU to the time when the task finished execution.
  // Queries the execution time of horizontal blur kernel.
  UINT64 execution_time = 0;
  cm_result_check(sync_event0->GetExecutionTime(execution_time));
  printf("Kernel horizontal_blur execution time is %llu nanoseconds\n",
      execution_time);

  // Queries the execution time of vertical blur kernel.
  cm_result_check(sync_event1->GetExecutionTime(execution_time));
  printf("Kernel vertical_blur execution time is %llu nanoseconds\n",
      execution_time);

  // Queries the execution time of unsharpen mask kernel.
  cm_result_check(sync_event2->GetExecutionTime(execution_time));
  printf("Kernel simple_USM execution time is %llu nanoseconds\n",
      execution_time);

  // Destroys the CmEvent.
  // CmEvent must be destroyed by the user explicitly.
  cm_result_check(queue->DestroyEvent(sync_event0));
  cm_result_check(queue->DestroyEvent(sync_event1));
  cm_result_check(queue->DestroyEvent(sync_event2));

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  cm_result_check(::DestroyCmDevice(device));

  // Saves the output image data into file "sharpen_small_out.bmp".
  output_image.save("sharpen_small_out.bmp");

  // Compares each pixel of output image with gold image. Set the tolerence of
  // each pixel difference as 5. If the difference of all pixel is within this
  // toletence, the result is correct. Otherwise there is something wrong.
  bool passed = cm::util::bitmap::BitMap::checkResult("sharpen_small_out.bmp",
                                                      "sharpen_gt_gold.bmp",
                                                      5);

  std::cout << (passed ? "PASSED" : "FAILED");
  std::cout << '\n';

  return (passed ? 0 : -1);
}
