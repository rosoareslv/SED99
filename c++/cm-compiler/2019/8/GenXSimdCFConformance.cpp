/*
 * Copyright (c) 2019, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

//===----------------------------------------------------------------------===//
//
/// GenXSimdCFConformance
/// ---------------------
///
/// This pass checks that the use of SIMD control flow (llvm.genx.simdcf.goto
/// and llvm.genx.simdcf.join) conforms to the rules required to allow us to
/// generate actual goto and join instructions. If not, the intrinsics are
/// lowered to code that implements the defined semantics for the intrinsics,
/// but does not use SIMD CF instructions, so is usually less efficient.
///
/// It also makes certain transformations to make goto/join legal in terms of its
/// position in the basic block. These can fail silently, in which case the
/// conformance check will fail on the goto/join in question:
///
/// * A goto and its extractvalues must be at the end of the block. (Actually, if
///   the !any result of the goto is used in a conditional branch at the end of
///   the block, then the goto being baled into the branch means that it is
///   treated as being at the end of the block anyway. The only reason we need
///   to sink it here is to ensure that isGotoBlock works.)
///
/// * For a join label block (a block that is the JIP of other gotos/joins), a
///   join must come at the start of the block.
///
/// * For a branching join block (one whose conditional branch condition is the
///   !any result from a join), the join must be at the end of the block.
///
/// * For a block that has one join with both of the above true, we need to move
///   all other code out of the block.
///
/// The pass is run twice: an "early SIMD CF conformance pass" (a module pass)
/// just before GenXLowering, and a "late SIMD CF conformance pass" (a function
/// group pass) just before second baling.
///
/// The early pass is the one that checks for conformance, and lowers the goto
/// and join intrinsics if the code is not conformant. The conformance checks
/// implement the rules listed in the documentation for the goto and join
/// intrinsics.
///
/// Lowering a goto issues a "failed to optimize SIMD control flow" warning. No
/// clue is given in the warning as to what caused the conformance failure,
/// however you (a compiler developer) can find out (for a test case submitted
/// by a compiler user) by turning on -debug and looking at the output from this
/// pass.
///
/// The late pass checks again for conformance, but if the code is not
/// conformant, it just errors. We could lower the gotos and joins there too,
/// but it would be more fiddly as we would have to ensure that the code
/// conforms with what is expected at that stage of compilation, and there is
/// no further chance to optimize it there.
///
/// We are not expecting this error to happen.
///
/// Otherwise, the late pass sets the register category of the EM and RM values
/// to "EM" and "RM", so they do not get any register allocated.
///
/// Conformance rules
/// ^^^^^^^^^^^^^^^^^
/// 
/// If the goto and join intrinsics are not used in a way that conforms to the
/// rules, then they will still have the semantics in their spec, but this pass
/// will lower at least some of them to equivalent but less efficient code.
/// 
/// The rules are:
/// 
/// 1. Because the hardware has a single EM (execution mask) register, all EM
///    values input to and generated by these intrinsics must not interfere with
///    each other; that is, they must have disjoint live ranges. For the
///    purposes of determining interference, if any EM value is a phi node
///    with incoming constant all ones, then the constant all ones value is
///    counted as being live from the start of the function and is not allowed
///    to interfere with other EM values (although it can interfere with other
///    such constant all ones values).
/// 
/// 2. An EM value is allowed to be defined:
/// 
///    a. as part of the struct returned by one of these intrinsics;
/// 
///    b. by a phi node, as long as each incoming is either an EM value or
///       a constant all ones;
/// 
///    c. by an extractvalue extracting it from a struct containing an EM value;
/// 
///    d. as a function argument, as long as an EM value is also returned by the
///       function (perhaps as part of a struct);
/// 
///    e. by an insertvalue as part of a return value struct;
/// 
///    f. as the return value of a non-intrinsic call (perhaps as part of a struct),
///       as long as there is also a call arg that is an EM value, and the called
///       function has the corresponding function arg and return value as EM values;
/// 
/// 3. An EM value is allowed to be used:
/// 
///    a. as the OldEM input to one of these intrinsics;
/// 
///    b. in a phi node, as long as the result of the phi node is an EM value;
/// 
///    c. as the condition in a wrregion or select;
/// 
///    d. as the input to a shufflevector whose effect is to slice part of the EM
///       value starting at index 0, as long as the result of that slice is only
///       used as the condition in a wrregion or select;
/// 
///    e. as a call argument, as long as the corresponding function argument is an
///       EM value, and the call has an EM return value;
/// 
///    f. in a return (perhaps as part of a struct), as long as the function also
///       has an argument that is an EM value.
///  
///    For an EM value defined in a goto, or a join whose scalar BranchCond result
///    is used in a conditional branch, or in an extractvalue out of
///    the result of such a goto or join, the only use allowed in the same basic block
///    as the goto/join is such an extractvalue.
/// 
/// 4. The OldEM input to the two intrinsics must be either an EM value or
///    constant all ones. In the latter case, and in the case of a constant incoming
///    to an EM phi node, its live range is considered to reach
///    back through all paths to the function entry for the purposes of rule (1).
/// 
/// 5. Each join point has a web of RM (resume mask) values, linked as by rules (6)
///    and (7). All RM values within one join point's web must not interfere with
///    each other; that is, they must have disjoint live ranges. For the
///    purposes of determining interference, if an RM value is a phi node with
///    incoming constant all zeros, then the constant all zeros value is
///    counted as being live from the start of the function and is not allowed
///    to interfere with other RM values for this join (although it can
///    interfere with other such constant all zeros values).
/// 
/// 6. An RM value is allowed to be defined:
/// 
///    a. as part of the struct returned by ``llvm.genx.simdcf.goto``;
/// 
///    b. by a phi node, as long as each incoming is either an RM value or
///       a constant all zeros.
/// 
/// 7. An RM value is allowed to be used:
/// 
///    a. as the OldRM input to ``llvm.genx.simdcf.goto``;
/// 
///    b. as the RM input to ``llvm.genx.simdcf.join``, but only to one join in the
///       whole web;
/// 
///    c. in a phi node, as long as the result of the phi node is an RM value.
/// 
/// 8. The OldRM input to ``llvm.genx.simdcf.goto``, or the RM input to
///    ``llvm.genx.simdcf.join``, must be either an RM value, or constant all
///    zeros. In the latter case, and in the case of a constant incoming to an RM
///    phi node, its live range is considered to reach back through all paths
///    to the function entry or to the web's ``llvm.genx.simdcf.join`` for the
///    purposes of rule (5).
/// 
/// 9. The BranchCond struct element of the result of ``llvm.genx.simdcf.goto``
///    must either be unused (unextracted), or, after being extractvalued,
///    must have exactly one use, which is in a
///    conditional branch terminating the same basic block. In the unused case,
///    the basic block must end with an unconditional branch. (This is a goto
///    that is immediately followed by a join.)
/// 
/// 10. The BranchCond struct element of the result of ``llvm.genx.simdcf.join``
///     must either be unused (unextracted), or, after being extractvalued,
///     have exactly one use, which is in a conditional branch terminating the
///     same basic block.
/// 
/// 11. It must be possible to derive an ordering for the basic blocks in a
///     function such that, in the conditional branch using the result of any goto
///     or join, the "false" successor is fall-through and the "true" successor is
///     to a join later on in the sequence. For a goto followed by an
///     unconditional branch, the successor is fall-through _and_ the next join
///     in sequence.
/// 
/// **IR restriction**: goto and join intrinsics must conform to these rules
/// (since this pass lowers any that do not).
/// 
//===----------------------------------------------------------------------===//
#define DEBUG_TYPE "GENX_SIMDCFCONFORMANCE"

#include "FunctionGroup.h"
#include "GenX.h"
#include "GenXGotoJoin.h"
#include "GenXLiveness.h"
#include "GenXModule.h"
#include "GenXRegion.h"
#include "llvm/ADT/MapVector.h"
#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/PostOrderIterator.h"
#include "llvm/ADT/SetVector.h"
#include "llvm/Analysis/CFG.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DiagnosticInfo.h"
#include "llvm/IR/DiagnosticPrinter.h"
#include "llvm/IR/Dominators.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/PatternMatch.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Transforms/Utils/Local.h"

using namespace llvm;
using namespace genx;

static cl::opt<bool> EnableGenXGotoJoin("enable-genx-goto-join", cl::init(true), cl::Hidden,
                                        cl::desc("Enable use of Gen goto/join instructions for SIMD control flow."));

namespace {

// Diagnostic information for error/warning relating to SIMD control flow.
class DiagnosticInfoSimdCF : public DiagnosticInfoOptimizationBase {
private:
  static int KindID;
  static int getKindID() {
    if (KindID == 0)
      KindID = llvm::getNextAvailablePluginDiagnosticKind();
    return KindID;
  }
public:
  static void emit(Instruction *Inst, StringRef Msg, DiagnosticSeverity Severity = DS_Error);
  DiagnosticInfoSimdCF(DiagnosticSeverity Severity, const Function &Fn,
      const DebugLoc &DLoc, StringRef Msg)
      : DiagnosticInfoOptimizationBase((DiagnosticKind)getKindID(), Severity,
          /*PassName=*/nullptr, Msg, Fn, DLoc) {}
  // This kind of message is always enabled, and not affected by -rpass.
  virtual bool isEnabled() const override { return true; }
  static bool classof(const DiagnosticInfo *DI) {
    return DI->getKind() == getKindID();
  }
};
int DiagnosticInfoSimdCF::KindID = 0;

// GenX SIMD control flow conformance pass -- common data between early and
// late passes.
class GenXSimdCFConformance {
protected:
  Module *M;
  FunctionGroup *FG;
  FunctionGroupAnalysis *FGA;
  DominatorTreeGroupWrapperPass *DTWrapper;
  std::map<Function *, DominatorTree *> DTs;
  GenXLiveness *Liveness;
  bool Modified;
  SetVector<SimpleValue> EMVals;
  std::map<CallInst *, SetVector<SimpleValue>> RMVals;
private:
  SetVector<SimpleValue> EMValsStack;
  std::map<CallInst *, CallInst *> GotoJoinMap;
protected:
  GenXSimdCFConformance() : M(0), FG(0), FGA(0), DTWrapper(0), Liveness(0) {}
  void gatherEMVals();
  void gatherRMVals();
  void removeFromEMRMVals(Value *V);
  void moveCodeInGotoBlocks();
  void moveCodeInJoinBlocks();
  void ensureConformance();
  void canonicalizeEM();
  void clear() {
    DTs.clear();
    EMVals.clear();
    RMVals.clear();
    GotoJoinMap.clear();
  }
private:
  bool isLatePass() { return FG != nullptr; }
  void emptyBranchingJoinBlocksInFunc(Function *F);
  void emptyBranchingJoinBlock(CallInst *Join);
  DominatorTree *getDomTree(Function *F);
  bool hoistJoin(CallInst *Join);
  bool checkEMVal(SimpleValue EMVal);
  bool checkGoto(SimpleValue EMVal);
  bool checkJoin(SimpleValue EMVal);
  bool checkGotoJoin(SimpleValue EMVal);
  void removeBadEMVal(SimpleValue EMVal);
  void pushValues(Value *V);
  bool getConnectedVals(SimpleValue Val, int Cat, bool IncludeOptional, CallInst *OkJoin, SmallVectorImpl<SimpleValue> *ConnectedVals);
  void checkEMInterference();
  void checkInterference(SetVector<SimpleValue> *Vals, SetVector<Value *> *BadDefs, Instruction *ConstStop);
  Value *insertCond(Value *OldVal, Value *NewVal, const Twine &Name, Instruction *InsertBefore, DebugLoc DL);
  Value *truncateCond(Value *In, Type *Ty, const Twine &Name, Instruction *InsertBefore, DebugLoc DL);
  void lowerGoto(CallInst *Goto);
  void lowerJoin(CallInst *Join);
  void replaceGotoJoinUses(CallInst *GotoJoin, ArrayRef<Value *> Vals);
};

// GenX early SIMD control flow conformance pass
class GenXEarlySimdCFConformance
    : public GenXSimdCFConformance, public ModulePass {
public:
  static char ID;
  explicit GenXEarlySimdCFConformance() : ModulePass(ID) { }
  virtual StringRef getPassName() const { return "GenX early SIMD control flow conformance"; }
  void getAnalysisUsage(AnalysisUsage &AU) const {
    ModulePass::getAnalysisUsage(AU);
  }
  bool runOnModule(Module &M);
};

// GenX late SIMD control flow conformance pass
class GenXLateSimdCFConformance
    : public GenXSimdCFConformance, public FunctionGroupPass {
public:
  static char ID;
  explicit GenXLateSimdCFConformance() : FunctionGroupPass(ID) { }
  virtual StringRef getPassName() const { return "GenX late SIMD control flow conformance"; }
  void getAnalysisUsage(AnalysisUsage &AU) const {
    FunctionGroupPass::getAnalysisUsage(AU);
    AU.addRequired<DominatorTreeGroupWrapperPass>();
    AU.addRequired<GenXLiveness>();
    AU.addPreserved<GenXModule>();
    AU.addPreserved<GenXLiveness>();
    AU.addPreserved<FunctionGroupAnalysis>();
  }
  bool runOnFunctionGroup(FunctionGroup &FG);
  // createPrinterPass : get a pass to print the IR, together with the GenX
  // specific analyses
  virtual Pass *createPrinterPass(raw_ostream &O, const std::string &Banner) const
  { return createGenXGroupPrinterPass(O, Banner); }
private:
  void setCategories();
  void modifyEMUses(Value *EM);
};

} // end anonymous namespace

char GenXEarlySimdCFConformance::ID = 0;
namespace llvm { void initializeGenXEarlySimdCFConformancePass(PassRegistry &); }
INITIALIZE_PASS_BEGIN(GenXEarlySimdCFConformance, "GenXEarlySimdCFConformance", "GenXEarlySimdCFConformance", false, false)
INITIALIZE_PASS_END(GenXEarlySimdCFConformance, "GenXEarlySimdCFConformance", "GenXEarlySimdCFConformance", false, false)

ModulePass *llvm::createGenXEarlySimdCFConformancePass()
{
  initializeGenXEarlySimdCFConformancePass(*PassRegistry::getPassRegistry());
  return new GenXEarlySimdCFConformance();
}

char GenXLateSimdCFConformance::ID = 0;
namespace llvm { void initializeGenXLateSimdCFConformancePass(PassRegistry &); }
INITIALIZE_PASS_BEGIN(GenXLateSimdCFConformance, "GenXLateSimdCFConformance", "GenXLateSimdCFConformance", false, false)
INITIALIZE_PASS_DEPENDENCY(FunctionGroupAnalysis)
INITIALIZE_PASS_DEPENDENCY(DominatorTreeGroupWrapperPass)
INITIALIZE_PASS_DEPENDENCY(GenXLiveness)
INITIALIZE_PASS_DEPENDENCY(GenXModule)
INITIALIZE_PASS_END(GenXLateSimdCFConformance, "GenXLateSimdCFConformance", "GenXLateSimdCFConformance", false, false)

FunctionGroupPass *llvm::createGenXLateSimdCFConformancePass()
{
  initializeGenXLateSimdCFConformancePass(*PassRegistry::getPassRegistry());
  return new GenXLateSimdCFConformance();
}

/***********************************************************************
 * runOnModule : run the early SIMD control flow conformance pass for this
 *  module
 */
bool GenXEarlySimdCFConformance::runOnModule(Module &ArgM)
{
  Modified = false;
  M = &ArgM;
  FG = nullptr;
  FGA = nullptr;
  DTWrapper = nullptr;
  canonicalizeEM();
  // Gather the EM values, both from goto/join and phi nodes.
  gatherEMVals();
  // Gather the RM values from gotos and phi nodes.
  gatherRMVals();
  // Move code in goto and join blocks as necessary.
  moveCodeInGotoBlocks();
  moveCodeInJoinBlocks();
  // Repeatedly check the code for conformance and lower non-conformant gotos
  // and joins until the code stabilizes.
  ensureConformance();
  clear();
  return Modified;
}

/***********************************************************************
 * runOnFunctionGroup : run the late SIMD control flow conformance pass for this
 * FunctionGroup
 */
bool GenXLateSimdCFConformance::runOnFunctionGroup(FunctionGroup &ArgFG)
{
  Modified = false;
  FG = &ArgFG;
  M = FG->getModule();
  // Get analyses that we use and/or modify.
  FGA = &getAnalysis<FunctionGroupAnalysis>();
  DTWrapper = &getAnalysis<DominatorTreeGroupWrapperPass>();
  Liveness = &getAnalysis<GenXLiveness>();
  // Gather the EM values, both from goto/join and phi nodes.
  gatherEMVals();
  // Gather the RM values from gotos and phi nodes.
  gatherRMVals();
  // Move code in goto and join blocks as necessary.
  moveCodeInGotoBlocks();
  moveCodeInJoinBlocks();
  // Check the code for conformance. In this late pass, we do not expect to
  // find non-conformance.
  ensureConformance();
  // For remaining unlowered gotos and joins (the ones that will become SIMD
  // control flow instructions), mark the webs of EM and RM values as
  // category EM or RM respectively. For EM, this also modifies uses as needed.
  setCategories();
  clear();
  return Modified;
}

/***********************************************************************
 * gatherEMVals : gather the EM values, including phi nodes
 */
void GenXSimdCFConformance::gatherEMVals()
{
  // We find gotos and joins by scanning all uses of the intrinsics and (in the
  // case of the late pass) ignoring ones not in this function group, rather
  // than scanning the whole IR.
  Type *I1Ty = Type::getInt1Ty(M->getContext());
  for (unsigned IID = Intrinsic::genx_simdcf_goto;
      IID != 2 * Intrinsic::genx_simdcf_join - Intrinsic::genx_simdcf_goto;
      IID += Intrinsic::genx_simdcf_join - Intrinsic::genx_simdcf_goto) {
    Type *EMTy = VectorType::get(I1Ty, 32);
    for (unsigned Width = 1; Width <= 32; Width <<= 1) {
      Type *Tys[] = { EMTy, VectorType::get(I1Ty, Width) };
      auto GotoJoinFunc = Intrinsic::getDeclaration(M, (Intrinsic::ID)IID, Tys);
      for (auto ui = GotoJoinFunc->use_begin(), ue = GotoJoinFunc->use_end();
          ui != ue; ++ui) {
        auto GotoJoin = dyn_cast<CallInst>(ui->getUser());
        if (!GotoJoin)
          continue;
        if (FG && (FGA->getGroup(GotoJoin->getParent()->getParent()) != FG
            || ui->getOperandNo() != GotoJoin->getNumArgOperands()))
          continue;
        // We have a goto/join (in our function group in the case of the late
        // pass).  Add the EM value (struct index 0) to EMVals.
        EMVals.insert(SimpleValue(GotoJoin, 0));
        // Also add its EM input to EMVals, if not a constant.
        if (!isa<Constant>(GotoJoin->getOperand(0)))
          EMVals.insert(SimpleValue(GotoJoin->getOperand(0), 0));
      }
    }
  }
  // Find related phi nodes and values related by insertvalue/extractvalue/call
  // using EMVal as a worklist.
  for (unsigned i = 0; i != EMVals.size(); ++i) {
    SimpleValue EMVal = EMVals[i];
    // For this EM value, get the connected values.
    SmallVector<SimpleValue, 8> ConnectedVals;
    getConnectedVals(EMVal, RegCategory::EM, /*IncludeOptional=*/true,
        /*OkJoin=*/nullptr, &ConnectedVals);
    // Add the connected values to EMVals.
    for (auto j = ConnectedVals.begin(), je = ConnectedVals.end();
        j != je; ++j)
      if (!isa<Constant>(j->getValue()))
        EMVals.insert(*j);
  }
}

/***********************************************************************
 * gatherRMVals : gather RM values for each join
 */
void GenXSimdCFConformance::gatherRMVals()
{
  for (auto ji = EMVals.begin(), je = EMVals.end(); ji != je; ++ji) {
    auto EMVal = *ji;
    if (getIntrinsicID(EMVal.getValue()) != Intrinsic::genx_simdcf_join)
      continue;
    auto Join = cast<CallInst>(EMVal.getValue());
    // We have a join. Gather its web of RM values.
    auto RMValsEntry = &RMVals[Join];
    if (!isa<Constant>(Join->getOperand(1)))
      RMValsEntry->insert(Join->getOperand(1));
    for (unsigned rvi = 0; rvi != RMValsEntry->size(); ++rvi) {
      SimpleValue RM = (*RMValsEntry)[rvi];
      // RM is a value in this join's RM web. Get other values related by phi
      // nodes and extractvalues and gotos.
      SmallVector<SimpleValue, 8> ConnectedVals;
      getConnectedVals(RM, RegCategory::RM, /*IncludeOptional=*/true,
          Join, &ConnectedVals);
      for (auto j = ConnectedVals.begin(), je = ConnectedVals.end();
          j != je; ++j)
        if (!isa<Constant>(j->getValue()))
          RMValsEntry->insert(*j);
    }
  }
}

/***********************************************************************
 * removeFromEMRMVals : remove a value from EMVals or RMVals
 *
 * This is used just before erasing a phi node in moveCodeInJoinBlocks.
 */
void GenXSimdCFConformance::removeFromEMRMVals(Value *V)
{
  auto VT = dyn_cast<VectorType>(V->getType());
  if (!VT || !VT->getElementType()->isIntegerTy(1))
    return;
  if (EMVals.remove(SimpleValue(V, 0)))
    return;
  for (auto i = RMVals.begin(), e = RMVals.end(); i != e; ++i) {
    auto RMValsEntry = &i->second;
    if (RMValsEntry->remove(SimpleValue(V, 0)))
      return;
  }
}

/***********************************************************************
 * moveCodeInGotoBlocks : move code in goto blocks
 *
 * A goto and its extractvalues must be at the end of the block. (Actually, if
 * the !any result of the goto is used in a conditional branch at the end of
 * the block, then the goto being baled into the branch means that it is
 * treated as being at the end of the block anyway. The only reason we need to
 * sink it here is to ensure that isGotoBlock works.)
 *
 * This can silently fail to sink a goto, in which case checkGoto will spot that
 * the goto is not conformant.
 */
void GenXSimdCFConformance::moveCodeInGotoBlocks()
{
  for (auto gi = EMVals.begin(), ge = EMVals.end(); gi != ge; ++gi) {
    auto EMVal = *gi;
    if (getIntrinsicID(EMVal.getValue()) != Intrinsic::genx_simdcf_goto)
      continue;
    auto Goto = cast<CallInst>(EMVal.getValue());
    // We want to sink the goto and its extracts. In fact we hoist any other
    // instruction, checking that it does not use the extracts.
    for (Instruction *NextInst = Goto->getNextNode();;) {
      auto Inst = NextInst;
      if (isa<TerminatorInst>(Inst))
        break;
      assert(Inst);
      NextInst = Inst->getNextNode();
      if (auto Extract = dyn_cast<ExtractValueInst>(Inst))
        if (Extract->getOperand(0) == Goto)
          continue;
      for (unsigned oi = 0, oe = Inst->getNumOperands(); oi != oe; ++oi)
        if (auto Extract = dyn_cast<ExtractValueInst>(Inst->getOperand(oi)))
          if (Extract->getOperand(0) == Goto) {
            DEBUG(dbgs() << "moveCodeInGotoBlocks: " << Goto->getName() << " failed\n");
            return; // Intervening instruction uses extract of goto; abandon
          }
      // Hoist the instruction.
      Inst->removeFromParent();
      Inst->insertBefore(Goto);
    }
  }
}

/***********************************************************************
 * moveCodeInJoinBlocks : move code in join blocks as necessary
 *
 * 1. For a join label block (a block that is the JIP of other gotos/joins), a
 *    join must come at the start of the block.
 *
 * 2. For a branching join block (one whose conditional branch condition is the
 *    !any result from a join), the join must be at the end of the block.
 *
 * 3. For a block that has one join with both of the above true, we need to move
 *    all other code out of the block.
 *
 * We achieve this as follows:
 *
 * a. First handle case 3. For any such block, hoist any other code to the end
 *    of its immediate dominator. To allow for the immediate dominator also
 *    being a case 3 join, we process blocks in post-order depth first search
 *    order, so we visit a block before its dominator. Thus code from a case 3
 *    join block eventually gets moved up to its closest dominating block that
 *    is not a case 3 join block.
 *
 *    Because it is more convenient and does not hurt, we also hoist the code
 *    before the first join in a block that initially looks like it is case 3,
 *    even if it then turns out not to be a case 3 join because it has multiple
 *    joins.
 *
 * b. Then scan all joins handling case 1.
 *
 * c. No need to handle case 2 here, as it (together with a similar requirement
 *    to sink a goto in a branching goto block) is checked in checkConformance
 *    and treated as sunk subsequently by virtue of getting baled in to the
 *    branch.
 *
 * This happens in both SIMD CF conformance passes, in case constant loading
 * etc sneaks code back into the wrong place in a join block. Any pass after
 * the late SIMD CF conformance pass needs to be careful not to sneak code back
 * into a join block.
 *
 * Any failure to do the above is not flagged here, but it will be spotted when
 * checking the join for conformance.
 *
 * moveCodeInGotoBlocks needs to run first, as we rely on its sinking of an
 * unconditional branch goto for isBranchingGotoJoinBlock to work.
 */
void GenXSimdCFConformance::moveCodeInJoinBlocks()
{
  // a. Handle case 3 join blocks.
  if (!FG) {
    // Early pass: iterate all funcs in the module.
    for (auto mi = M->begin(), me = M->end(); mi != me; ++mi) {
      Function *F = &*mi;
      if (!F->empty()) 
        emptyBranchingJoinBlocksInFunc(F);
    }
  } else {
    // Late pass: iterate all funcs in the function group.
    for (auto fgi = FG->begin(), fge = FG->end(); fgi != fge; ++fgi) {
      Function *F = *fgi;
      emptyBranchingJoinBlocksInFunc(F);
    }
  }
  // b. Process all other joins (in fact all joins, but ones successfully
  // processed above will not need anything doing).
  // Get the joins into a vector first, because the code below modifies EMVals.
  SmallVector<CallInst *, 4> Joins;
  for (auto ji = EMVals.begin(), je = EMVals.end(); ji != je; ++ji) {
    auto EMVal = *ji;
    if (getIntrinsicID(EMVal.getValue()) != Intrinsic::genx_simdcf_join)
      continue;
    Joins.push_back(cast<CallInst>(EMVal.getValue()));
  }
  for (auto ji = Joins.begin(), je = Joins.end(); ji != je; ++ji) {
    auto Join = *ji;
    auto JoinBlock = Join->getParent();
    if (GotoJoin::isJoinLabel(JoinBlock, /*SkipCriticalEdgeSplitter=*/true))
      hoistJoin(Join);
    else {
      // The join is in a block that is not a join label. Also check the case
      // that there is a predecessor that:
      // 1. has one successor; and
      // 2. is empty other than phi nodes; and
      // 3. is a join label.
      // In that case we merge the two blocks, merging phi nodes.
      // I have seen this situation arise where LLVM decides to add a loop
      // pre-header block.
      BasicBlock *PredBlock = nullptr;
      for (auto ui = JoinBlock->use_begin(), ue = JoinBlock->use_end(); ui != ue; ++ui) {
        auto Br = dyn_cast<BranchInst>(ui->getUser());
        if (!Br || Br->isConditional())
          continue;
        auto BB = Br->getParent();
        if (BB->getFirstNonPHIOrDbg() != Br)
          continue;
        if (GotoJoin::isJoinLabel(BB, /*SkipCriticalEdgeSplitter=*/true)) {
          PredBlock = BB;
          break;
        }
      }
      if (PredBlock) {
        // We have such a predecessor block. First hoist the join in our block.
        if (hoistJoin(Join)) {
          // Join hoisting succeeded. Now merge the blocks.
          DEBUG(dbgs() << "moveCodeInJoinBlocks: merging " << PredBlock->getName()
              << " into " << JoinBlock->getName() << "\n");
          // First adjust the phi nodes to include both blocks' incomings.
          for (auto Phi = dyn_cast<PHINode>(&JoinBlock->front()); Phi;
              Phi = dyn_cast<PHINode>(Phi->getNextNode())) {
            int Idx = Phi->getBasicBlockIndex(PredBlock);
            if (Idx >= 0) {
              Value *Incoming = Phi->getIncomingValue(Idx);
              auto PredPhi = dyn_cast<PHINode>(Incoming);
              if (PredPhi && PredPhi->getParent() != PredBlock)
                PredPhi = nullptr;
              if (PredPhi) {
                // The incoming in JoinBlock is a phi node in PredBlock. Add its
                // incomings.
                Phi->removeIncomingValue(Idx, /*DeletePHIIfEmpty=*/false);
                for (unsigned oi = 0, oe = PredPhi->getNumIncomingValues();
                    oi != oe; ++oi)
                  Phi->addIncoming(PredPhi->getIncomingValue(oi),
                      PredPhi->getIncomingBlock(oi));
              } else {
                // Otherwise, add the predecessors of PredBlock to the phi node
                // in JoinBlock.
                for (auto ui2 = PredBlock->use_begin(),
                    ue2 = PredBlock->use_end(); ui2 != ue2; ++ui2)
                  if (auto Term = dyn_cast<TerminatorInst>(ui2->getUser())) {
                    auto PredPred = Term->getParent();
                    if (Idx >= 0) {
                      Phi->setIncomingBlock(Idx, PredPred);
                      Idx = -1;
                    } else
                      Phi->addIncoming(Incoming, PredPred);
                  }
              }
            }
          }
          // Any phi in PredBlock that is not used in a phi in JoinBlock (and
          // so still has at least one use after the code above) needs to be
          // moved to JoinBlock, with itself added as the extra incomings. The
          // incoming blocks to JoinBlock other than PredBlock must be loop
          // back edges.
          for (;;) {
            auto Phi = dyn_cast<PHINode>(&PredBlock->front());
            if (!Phi)
              break;
            if (Phi->use_empty()) {
              removeFromEMRMVals(Phi);
              Phi->eraseFromParent();
              continue;
            }
            for (auto ui = JoinBlock->use_begin(), ue = JoinBlock->use_end();
                ui != ue; ++ui) {
              auto Term = dyn_cast<TerminatorInst>(ui->getUser());
              if (!Term)
                continue;
              auto TermBB = Term->getParent();
              if (TermBB == PredBlock)
                continue;
              Phi->addIncoming(Phi, TermBB);
            }
            Phi->removeFromParent();
            Phi->insertBefore(&JoinBlock->front());
          }
          // Adjust branches targeting PredBlock to target JoinBlock instead.
          PredBlock->replaceAllUsesWith(JoinBlock);
          // Remove PredBlock.
          PredBlock->eraseFromParent();
        }
      }
    }
  }
}

/***********************************************************************
 * emptyBranchingJoinBlocksInFunc : empty other instructions out of each
 *    block in a function that is both a join label and a branching join block
 *
 * See comment for moveCodeInJoinBlocks above.
 */
void GenXSimdCFConformance::emptyBranchingJoinBlocksInFunc(Function *F)
{
  for (auto i = po_begin(&F->getEntryBlock()), e = po_end(&F->getEntryBlock());
      i != e; ++i) {
    BasicBlock *BB = *i;
    if (!GotoJoin::isJoinLabel(BB, /*SkipCriticalEdgeSplitter=*/true))
      continue;
    CallInst *Join = GotoJoin::isBranchingJoinBlock(BB);
    if (!Join)
      continue;
    emptyBranchingJoinBlock(Join);
  }
}

/***********************************************************************
 * emptyBranchingJoinBlock : empty instructions other than the join (and its
 *      extracts) from this branching join block
 */
void GenXSimdCFConformance::emptyBranchingJoinBlock(CallInst *Join)
{
  BasicBlock *BB = Join->getParent();
  Instruction *InsertBefore = nullptr;
  for (Instruction *NextInst = BB->getFirstNonPHIOrDbg();;) {
    auto Inst = NextInst;
    if (isa<TerminatorInst>(Inst))
      break;
    NextInst = Inst->getNextNode();
    if (Inst == Join)
      continue; // do not hoist the join itself
    if (getIntrinsicID(Inst) == Intrinsic::genx_simdcf_join)
      break; // we have encountered another join; there must be more than one
    if (auto EV = dyn_cast<ExtractValueInst>(Inst))
      if (EV->getOperand(0) == Join)
        continue; // do not hoist an extract of the join
    // Check that the instruction's operands do not use anything in this block
    // (the phi nodes, or the join and extracts being left behind).
    for (unsigned oi = 0, oe = Inst->getNumOperands(); oi != oe; ++oi) {
      auto Opnd = dyn_cast<Instruction>(Inst->getOperand(oi));
      if (Opnd && Opnd->getParent() == BB) {
        DEBUG(dbgs() << "Failed to empty branching join label for join " << Join->getName() << "\n");
        return; // Instruction uses something in this block: abandon.
      }
    }
    if (!InsertBefore) {
      // Lazy determination of the insert point. If it is a branching goto/join
      // block, insert before the goto/join.
      auto InsertBB = getDomTree(BB->getParent())->getNode(BB)
            ->getIDom()->getBlock();
      InsertBefore = GotoJoin::isBranchingGotoJoinBlock(InsertBB);
      if (!InsertBefore)
        InsertBefore = InsertBB->getTerminator();
    }
    // Hoist the instruction.
    Inst->removeFromParent();
    Inst->insertBefore(InsertBefore);
    Modified = true;
  }
}

/***********************************************************************
 * getDomTree : get dominator tree for a function
 */
DominatorTree *GenXSimdCFConformance::getDomTree(Function *F)
{
  if (!DTWrapper) {
    // In early pass, which is a module pass.
    if (!DTs[F]) {
      auto DT = new DominatorTree;
      DT->recalculate(*F);
      DTs[F] = DT;
    }
    return DTs[F];
  }
  // In late pass, use the DominatorTreeGroupWrapper.
  return DTWrapper->getDomTree(F);
}

/***********************************************************************
 * hoistJoin : hoist a join to the top of its basic block if possible
 *
 * Return:  whether succeeded
 *
 * This is used for a join in a block that is a join label, but not a branching
 * join block. See comment for emptyJoinBlocks above.
 *
 * There might be multiple joins in the function, and the one supplied is not
 * necessarily the first one. If it is a later one, this function will silently
 * fail, which is harmless. If it silently fails for the first join, then we
 * end up with a join label block that does not start with a join, which
 * checkConformance will spot later on.
 *
 * This function does return whether it has succeeded, which is used in
 * moveCodeInJoinBlocks in the case that it wants to merge a loop pre-header
 * back into the join block.
 */
bool GenXSimdCFConformance::hoistJoin(CallInst *Join)
{
  // This only works if no operand of the join uses one of the instructions
  // before it in the block, other than phi nodes.
  // However, if we find such an instruction and it is an extractvalue from the
  // result of an earlier goto/join in a different block, we can just move it
  // to after that goto/join.
  for (unsigned oi = 0, oe = Join->getNumArgOperands(); oi != oe; ++oi) {
    auto Opnd = dyn_cast<Instruction>(Join->getOperand(oi));
    if (!Opnd || isa<PHINode>(Opnd))
      continue;
    if (Opnd->getParent() == Join->getParent()) {
      if (auto EV = dyn_cast<ExtractValueInst>(Opnd)) {
        unsigned IID = getIntrinsicID(EV->getOperand(0));
        if (IID == Intrinsic::genx_simdcf_goto
            || IID == Intrinsic::genx_simdcf_join) {
          auto GotoJoin = cast<CallInst>(EV->getOperand(0));
          if (GotoJoin->getParent() != Join->getParent()) {
            DEBUG(dbgs() << "moving out of join block: " << *EV << "\n");
            EV->removeFromParent();
            EV->insertBefore(GotoJoin->getNextNode());
            continue;
          }
        }
      }
      DEBUG(dbgs() << "hoistJoin: " << Join->getName() << " failed\n");
      return false; // failed -- join uses non-phi instruction before it
    }
  }
  // Hoist the join.
  auto BB = Join->getParent();
  auto InsertBefore = BB->getFirstNonPHIOrDbg();
  if (InsertBefore == Join)
    return true; // already at start
  Join->removeFromParent();
  Join->insertBefore(InsertBefore);
  Modified = true;
  return true;
}

/***********************************************************************
 * ensureConformance : check for conformance, and lower any non-conformant
 *    gotos and joins
 */
void GenXSimdCFConformance::ensureConformance()
{
  // Push all EM values onto the stack for checking. Push the joins last, since
  // we want to process those before their corresponding gotos, so that
  // GotoJoinMap is set for a goto by the time we process a valid goto.
  for (auto i = EMVals.begin(), e = EMVals.end(); i != e; ++i)
    if (getIntrinsicID(i->getValue()) != Intrinsic::genx_simdcf_join)
      EMValsStack.insert(*i);
  for (auto i = EMVals.begin(), e = EMVals.end(); i != e; ++i)
    EMValsStack.insert(*i);
  // Process the stack.
  SmallVector<CallInst *, 4> GotosToLower;
  SmallVector<CallInst *, 4> JoinsToLower;
  for (;;) {
    if (!EMValsStack.empty()) {
      // Remove and process the top entry on the stack.
      auto EMVal = EMValsStack.back();
      EMValsStack.pop_back();
      if (checkEMVal(EMVal))
        continue;
      removeBadEMVal(EMVal);
      if (!EMVal.getIndex()) {
        if (auto CI = dyn_cast<CallInst>(EMVal.getValue())) {
          switch (getIntrinsicID(EMVal.getValue())) {
            case Intrinsic::genx_simdcf_goto:
              GotosToLower.push_back(CI);
              break;
            case Intrinsic::genx_simdcf_join:
              JoinsToLower.push_back(CI);
              break;
          }
        }
      }
      continue;
    }
    // The stack is empty. Check for EM values interfering with each other.
    checkEMInterference();
    if (EMValsStack.empty()) {
      // Stack still empty; we have finished.
      break;
    }
  }
  // In the late pass, we are not expecting to have found any non-conformant
  // gotos and joins that need lowering. All such gotos and joins should have
  // been identified in the early pass, unless passes in between have
  // transformed the code in an unexpected way that has made the simd CF
  // non-conformant. Give an error here if this has happened.
  if (isLatePass() && (!GotosToLower.empty() || !JoinsToLower.empty()))
    llvm_unreachable("unexpected non-conformant SIMD CF in late SIMD CF conformance pass");
  // Lower gotos and joins that turned out to be non-conformant.
  for (auto i = GotosToLower.begin(), e = GotosToLower.end(); i != e; ++i)
    lowerGoto(*i);
  for (auto i = JoinsToLower.begin(), e = JoinsToLower.end(); i != e; ++i)
    lowerJoin(*i);

}

/***********************************************************************
 * checkEMVal : check an EM value for conformance
 *
 * Return:    true if ok, false if the EM value needs to be removed
 */
bool GenXSimdCFConformance::checkEMVal(SimpleValue EMVal)
{
  DEBUG(dbgs() << "checkEMVal " << *EMVal.getValue() << "#" << EMVal.getIndex() << "\n");
  if (!EnableGenXGotoJoin)
    return false; // use of goto/join disabled
  SmallVector<SimpleValue, 8> ConnectedVals;
  if (!getConnectedVals(EMVal, RegCategory::EM, /*IncludeOptional=*/false,
        /*OkJoin=*/nullptr, &ConnectedVals)) {
    DEBUG(dbgs() << "invalid def or uses\n");
    return false; // something invalid about the EM value itself
  }
  // Check that all connected values are EM values.
  for (auto i = ConnectedVals.begin(), e = ConnectedVals.end(); i != e; ++i) {
    SimpleValue ConnectedVal = *i;
    if (auto C = dyn_cast<Constant>(ConnectedVal.getValue())) {
      if (!C->isAllOnesValue()) {
        DEBUG(dbgs() << "ConnectedVal is constant that is not all ones\n");
        return false; // uses constant that is not all ones, invalid
      }
    } else if (!EMVals.count(ConnectedVal)) {
      DEBUG(dbgs() << "ConnectedVal is not in EMVals\n");
      return false; // connected value is not in EMVals
    }
  }
  switch (getIntrinsicID(EMVal.getValue())) {
    case Intrinsic::genx_simdcf_goto:
      return checkGoto(EMVal);
    case Intrinsic::genx_simdcf_join:
      return checkJoin(EMVal);
  }
  return true;
}

/***********************************************************************
 * checkGotoJoinSunk : check whether a goto/join is sunk to the bottom of
 *    its basic block, other than extractvalues from its result
 */
static bool checkGotoJoinSunk(CallInst *GotoJoin)
{
  for (Instruction *Inst = GotoJoin;;) {
    Inst = Inst->getNextNode();
    if (isa<TerminatorInst>(Inst)) {
      if (!isa<BranchInst>(Inst))
        return false;
      break;
    }
    auto EV = dyn_cast<ExtractValueInst>(Inst);
    if (!EV || EV->getOperand(0) != GotoJoin)
      return false;
  }
  return true;
}

/***********************************************************************
 * checkGoto : check conformance of an actual goto instruction
 */
bool GenXSimdCFConformance::checkGoto(SimpleValue EMVal)
{
  if (!checkGotoJoin(EMVal))
    return false;
  // Check that there is a linked join. (We do not need to check here that the
  // linked join is an EM value; that happened in checkEMVal due to the join
  // being treated as a linked value in getConnectedVals.)
  auto Goto = cast<CallInst>(EMVal.getValue());
  if (!GotoJoinMap[Goto]) {
    DEBUG(dbgs() << "checkGoto: no linked join\n");
    return false;
  }
  // Check that the goto is sunk to the end of the block, other than extracts
  // from its result, and a branch. moveCodeInGotoBlocks ensures that if
  // possible; if that failed, this conformance check fails.
  if (!checkGotoJoinSunk(Goto)) {
    DEBUG(dbgs() << "checkGoto: not sunk\n");
    return false;
  }
  return true;
}

/***********************************************************************
 * checkJoin : check conformance of an actual join instruction
 */
bool GenXSimdCFConformance::checkJoin(SimpleValue EMVal)
{
  if (!checkGotoJoin(EMVal))
    return false;
  // Check that the join is at the start of the block. emptyJoinBlock should
  // have ensured this, unless the code was such that it could not.
  auto Join = cast<CallInst>(EMVal.getValue());
  if (!GotoJoin::isValidJoin(Join)) {
    DEBUG(dbgs() << "not valid join\n");
    return false;
  }
  // If the !any result of this join is used in a conditional branch at the
  // end, check that the join is sunk to the end of the block, other than
  // extracts from its result, and a branch. moveCodeInJoinBlocks ensures that
  // if possible; if that failed, this conformance check fails.
  if (auto Br = dyn_cast<BranchInst>(Join->getParent()->getTerminator()))
    if (Br->isConditional())
      if (auto EV = dyn_cast<ExtractValueInst>(Br->getCondition()))
        if (EV->getOperand(0) == Join)
          if (!checkGotoJoinSunk(Join)) {
            DEBUG(dbgs() << "checkJoin: not sunk\n");
            return false;
          }
  // Gather the web of RM values.
  auto RMValsEntry = &RMVals[Join];
  RMValsEntry->clear();
  DEBUG(dbgs() << "gather web of RM vals for " << *Join << "\n");
  if (!isa<Constant>(Join->getOperand(1)))
    RMValsEntry->insert(Join->getOperand(1));
  for (unsigned rvi = 0; rvi != RMValsEntry->size(); ++rvi) {
    SimpleValue RM = (*RMValsEntry)[rvi];
    // RM is a value in this join's RM web. Get other values related by phi
    // nodes and extractvalues and gotos.
    SmallVector<SimpleValue, 8> ConnectedVals;
    bool Ok = getConnectedVals(RM, RegCategory::RM, /*IncludeOptional=*/false,
        Join, &ConnectedVals);
    DEBUG(
      dbgs() << "getConnectedVals: " << RM.getValue()->getName() << "#" << RM.getIndex() << "\n";
      for (auto i = ConnectedVals.begin(), e = ConnectedVals.end(); i != e; ++i)
        dbgs() << "   " << i->getValue()->getName() << "#" << i->getIndex() << "\n"
    );
    if (!Ok) {
      DEBUG(dbgs() << "illegal RM value in web\n");
      return false;
    }
    for (auto j = ConnectedVals.begin(), je = ConnectedVals.end();
        j != je; ++j) {
      SimpleValue ConnectedVal = *j;
      if (auto C = dyn_cast<Constant>(ConnectedVal.getValue())) {
        // A constant in the RM web must be all zeros.
        if (!C->isNullValue()) {
          DEBUG(dbgs() << "non-0 constant in RM web\n");
          return false;
        }
      } else {
        // Insert the non-constant value.  If it is a goto with struct index
        // other than 1, it is illegal.
        if (RMValsEntry->insert(ConnectedVal)) {
          DEBUG(dbgs() << "New one: " << ConnectedVal.getValue()->getName() << "#" << ConnectedVal.getIndex() << "\n");
          switch (getIntrinsicID(ConnectedVal.getValue())) {
            case Intrinsic::genx_simdcf_join:
              DEBUG(dbgs() << "multiple joins in RM web\n");
              return false;
            case Intrinsic::genx_simdcf_goto:
              if (ConnectedVal.getIndex() != 1/* struct index of RM result */) {
                DEBUG(dbgs() << "wrong struct index in goto\n");
                return false;
              }
              break;
          }
        }
      }
    }
  }
  // Check whether the RM values interfere with each other.
  SetVector<Value *> BadDefs;
  checkInterference(RMValsEntry, &BadDefs, Join);
  if (!BadDefs.empty()) {
    DEBUG(dbgs() << "RMs interfere\n");
    return false;
  }
  // Set GotoJoinMap for each goto in the RM web.
  for (unsigned rvi = 0; rvi != RMValsEntry->size(); ++rvi) {
    SimpleValue RM = (*RMValsEntry)[rvi];
    if (getIntrinsicID(RM.getValue()) == Intrinsic::genx_simdcf_goto)
      GotoJoinMap[cast<CallInst>(RM.getValue())] = Join;
  }
  return true;
}

/***********************************************************************
 * getEmptyCriticalEdgeSplitterSuccessor : if BB is an empty critical edge
 *    splitter block (one predecessor and one successor), then return the
 *    single successor
 */
static BasicBlock *getEmptyCriticalEdgeSplitterSuccessor(BasicBlock *BB)
{
  if (!BB->hasOneUse())
    return nullptr; // not exactly one predecessor
  auto Term = dyn_cast<TerminatorInst>(BB->getFirstNonPHIOrDbg());
  if (!Term)
    return nullptr; // not empty
  if (Term->getNumSuccessors() != 1)
    return nullptr; // not exactly one successor
  return Term->getSuccessor(0);
}

/***********************************************************************
 * checkGotoJoin : common code to check conformance of an actual goto or join
 *    instruction
 */
bool GenXSimdCFConformance::checkGotoJoin(SimpleValue EMVal)
{
  auto CI = cast<CallInst>(EMVal.getValue());
  // If there is an extract of the scalar result of the goto/join, check that
  // it is used in the conditional branch at the end of the block.
  ExtractValueInst *ExtractScalar = nullptr;
  for (auto ui = CI->use_begin(), ue = CI->use_end(); ui != ue; ++ui)
    if (auto EV = dyn_cast<ExtractValueInst>(ui->getUser()))
      if (!isa<VectorType>(EV->getType())) {
        if (ExtractScalar) {
          DEBUG(dbgs() << "goto/join has more than one extract of its !any result\n");
          return false;
        }
        ExtractScalar = EV;
      }
  if (ExtractScalar) {
    if (!ExtractScalar->hasOneUse()) {
      DEBUG(dbgs() << "goto/join's !any result does not have exactly one use\n");
      return false;
    }
    auto Br = dyn_cast<BranchInst>(ExtractScalar->use_begin()->getUser());
    if (!Br || Br->getParent() != CI->getParent()) {
      DEBUG(dbgs() << "goto/join's !any result not used in conditional branch in same block\n");
      return false;
    }
    // For a goto/join with a conditional branch, check that the "true"
    // successor is a join label. We also tolerate there being an empty
    // critical edge splitter block in between; this will get removed in
    // setCategories in this pass.
    BasicBlock *TrueSucc = Br->getSuccessor(0);
    Instruction *First = TrueSucc->getFirstNonPHIOrDbg();
    if (getIntrinsicID(First) != Intrinsic::genx_simdcf_join) {
      // "True" successor is not a join label. Check for an empty critical edge
      // splitter block in between.
      TrueSucc = getEmptyCriticalEdgeSplitterSuccessor(TrueSucc);
      if (!TrueSucc) {
        DEBUG(dbgs() << "goto/join true successor not join label\n");
        return false; // Not empty critical edge splitter
      }
      if (getIntrinsicID(TrueSucc->getFirstNonPHIOrDbg())
          != Intrinsic::genx_simdcf_join) {
        DEBUG(dbgs() << "goto/join true successor not join label\n");
        return false; // Successor is not join label
      }
    }
  }
  return true;
}

/***********************************************************************
 * removeBadEMVal : remove a bad EM value
 *
 * This removes a non-conformant EM value, and pushes any connected EM value
 * onto the stack so it gets re-checked for conformance.
 */
void GenXSimdCFConformance::removeBadEMVal(SimpleValue EMVal)
{
  DEBUG(
    dbgs() << "removeBadEMVal ";
    EMVal.print(dbgs());
    dbgs() << "\n"
  );
  // Remove the EM value.
  if (!EMVals.remove(EMVal))
    return; // was not in EMVals
  // Push anything related to it onto the stack for re-checking.
  SmallVector<SimpleValue, 8> ConnectedVals;
  getConnectedVals(EMVal, RegCategory::EM, /*IncludeOptional=*/true,
        /*OkJoin=*/nullptr, &ConnectedVals);
  for (auto i = ConnectedVals.begin(), e = ConnectedVals.end(); i != e; ++i) {
    SimpleValue ConnectedVal = *i;
    if (EMVals.count(ConnectedVal))
      EMValsStack.insert(ConnectedVal);
  }
}

/***********************************************************************
 * pushValues : push EM struct elements in a value onto EMValsStack
 */
void GenXSimdCFConformance::pushValues(Value *V)
{
  for (unsigned si = 0, se = IndexFlattener::getNumElements(V->getType());
      si != se; ++si) {
    SimpleValue SV(V, si);
    if (EMVals.count(SV))
      EMValsStack.insert(SV);
  }
}

/***********************************************************************
 * checkAllUsesAreSelectOrWrRegion : check that all uses of a value are the
 *    condition in select or wrregion or wrpredpredregion (or a predicate
 *    in a non-ALU intrinsic)
 *
 * This is used in getConnectedVals below for the result of a use of an EM
 * value in an rdpredregion, or a shufflevector that is a slice so will be
 * lowered to rdpredregion.
 */
static bool checkAllUsesAreSelectOrWrRegion(Value *V)
{
  for (auto ui2 = V->use_begin(); ui2 != V->use_end(); /*empty*/) {
    auto User2 = cast<Instruction>(ui2->getUser());
    unsigned OpNum = ui2->getOperandNo();
    ++ui2;

    if (isa<SelectInst>(User2))
      continue;

    // Matches uses that can be turned into select.
    if (auto BI = dyn_cast<BinaryOperator>(User2)) {
      auto Opc = BI->getOpcode();
      Constant *AllOne = Constant::getAllOnesValue(V->getType());
      Constant *AllNul = Constant::getNullValue(V->getType());

      // EM && X -> sel EM X 0
      // EM || X -> sel EM 1 X
      if (Opc == BinaryOperator::And ||
          Opc == BinaryOperator::Or) {
        Value *Ops[3] = {V, nullptr, nullptr};
        if (Opc == BinaryOperator::And) {
          Ops[1] = BI->getOperand(1 - OpNum);
          Ops[2] = AllNul;
        } else if (Opc == BinaryOperator::Or) {
          Ops[1] = AllOne;
          Ops[2] = BI->getOperand(1 - OpNum);
        }
        auto SI = SelectInst::Create(Ops[0], Ops[1], Ops[2], ".revsel", BI, BI);
        BI->replaceAllUsesWith(SI);
        BI->eraseFromParent();
        continue;
      }

      // ~EM || X ==> sel EM, X, 1
      using namespace PatternMatch;
      if (BI->hasOneUse() &&
          BI->user_back()->getOpcode() == BinaryOperator::Or &&
          match(BI, m_Xor(m_Specific(V), m_Specific(AllOne)))) {
        Instruction *OrInst = BI->user_back();
        Value *Op = OrInst->getOperand(0) != BI ? OrInst->getOperand(0)
                                                : OrInst->getOperand(1);
        auto SI = SelectInst::Create(V, Op, AllOne, ".revsel", OrInst, OrInst);
        OrInst->replaceAllUsesWith(SI);
        OrInst->eraseFromParent();
        BI->eraseFromParent();
        continue;
      }

      // ~EM && X ==> sel EM, 0, X
      using namespace PatternMatch;
      if (BI->hasOneUse() &&
          BI->user_back()->getOpcode() == BinaryOperator::And &&
          match(BI, m_Xor(m_Specific(V), m_Specific(AllOne)))) {
        Instruction *AndInst = BI->user_back();
        Value *Op = AndInst->getOperand(0) != BI ? AndInst->getOperand(0)
                                                 : AndInst->getOperand(1);
        auto SI = SelectInst::Create(V, AllNul, Op, ".revsel", AndInst, AndInst);
        AndInst->replaceAllUsesWith(SI);
        AndInst->eraseFromParent();
        BI->eraseFromParent();
        continue;
      }
    } else if (auto CI = dyn_cast<CastInst>(User2)) {
      // Turn zext/sext to select.
      if (CI->getOpcode() == Instruction::CastOps::ZExt ||
          CI->getOpcode() == Instruction::CastOps::SExt) {
        unsigned NElts = V->getType()->getVectorNumElements();
        unsigned NBits = CI->getType()->getScalarSizeInBits();
        int Val = (CI->getOpcode() == Instruction::CastOps::ZExt) ? 1 : -1;
        APInt One(NBits, Val);
        Constant *LHS = ConstantVector::getSplat(
            NElts, ConstantInt::get(CI->getType()->getScalarType(), One));
        Constant *AllNul = Constant::getNullValue(CI->getType());
        auto SI = SelectInst::Create(V, LHS, AllNul, ".revsel", CI, CI);
        CI->replaceAllUsesWith(SI);
        CI->eraseFromParent();
        continue;
      }
    }

    unsigned IID = getIntrinsicID(User2);
    if (isWrRegion(IID))
      continue;
    if (IID == Intrinsic::genx_wrpredpredregion
        && OpNum == cast<CallInst>(User2)->getNumArgOperands() - 1)
      continue;
    if (IID != Intrinsic::not_intrinsic
        && !cast<CallInst>(User2)->doesNotAccessMemory())
      continue;
    return false;
  }
  return true;
}

/***********************************************************************
 * getConnectedVals : for a SimpleValue, get other SimpleValues connected to
 *    it through phi nodes, insertvalue, extractvalue, goto/join, and maybe
 *    args and return values
 *
 * Enter:   Val = SimpleValue to start at
 *          Cat = RegCategory::EM to do EM connections
 *                RegCategory::RM to do RM connections
 *          IncludeOptional = for EM connections, include optional connections
 *                where Val is a function arg and it is connected to call args,
 *                and where Val is the operand to return and it is connected to
 *                the returned value at call sites
 *          OkJoin = for RM connections, error if a use in a join other than
 *                this one is found
 *          ConnectedVals = vector to store connected values in
 *
 * Return:  true if ok, false if def or some use is not suitable for EM/RM
 *
 * The provided value must be non-constant, but the returned connected values
 * may include constants. Duplicates may be stored in ConnectedVals.
 *
 * This function is used in three different ways by its callers:
 *
 * 1. to gather a web of putative EM values or RM values starting at goto/join
 *    instructions;
 *
 * 2. to test whether a putative EM/RM value is valid by whether its connected
 *    neighbors are EM/RM values;
 *
 * 3. when removing a value from the EM/RM values list, to find its connected
 *    neighbors to re-run step 2 on each of them.
 */
bool GenXSimdCFConformance::getConnectedVals(SimpleValue Val, int Cat,
    bool IncludeOptional, CallInst *OkJoin,
    SmallVectorImpl<SimpleValue> *ConnectedVals)
{
  // Check the def first.
  if (auto Arg = dyn_cast<Argument>(Val.getValue())) {
    if (Cat != RegCategory::EM)
      return false; // can't have RM argument
    // Connected to some return value. There is a problem here in that it might
    // find another predicate return value that is nothing to do with SIMD CF,
    // and thus stop SIMD CF being optimized. But passing a predicate in and
    // out of a function is rare outside of SIMD CF, so we do not worry about
    // that.
    Function *F = Arg->getParent();
    unsigned RetIdx = 0;
    auto RetTy = F->getReturnType();
    auto ValTy = IndexFlattener::getElementType(
        Val.getValue()->getType(), Val.getIndex());
    if (auto ST = dyn_cast<StructType>(RetTy)) {
      for (unsigned End = IndexFlattener::getNumElements(ST); ; ++RetIdx) {
        if (RetIdx == End)
          return false; // no predicate ret value found
        if (IndexFlattener::getElementType(ST, RetIdx) == ValTy)
          break;
      }
    } else if (RetTy != ValTy)
      return false; // no predicate ret value found
    for (auto fi = F->begin(), fe = F->end(); fi != fe; ++fi)
      if (auto Ret = dyn_cast<ReturnInst>(fi->getTerminator()))
        ConnectedVals->push_back(SimpleValue(Ret->getOperand(0), RetIdx));
    if (IncludeOptional) {
      // With IncludeOptional, also add the corresponding arg at each call
      // site.
      for (auto ui = F->use_begin(), ue = F->use_end(); ui != ue; ++ui)
        if (auto CI = dyn_cast<CallInst>(ui->getUser()))
          ConnectedVals->push_back(
              SimpleValue(CI->getArgOperand(Arg->getArgNo()), Val.getIndex()));
    }
  } else if (auto Phi = dyn_cast<PHINode>(Val.getValue())) {
    // phi: add (the corresponding struct element of) each incoming
    for (unsigned oi = 0, oe = Phi->getNumIncomingValues(); oi != oe; ++oi)
      ConnectedVals->push_back(
          SimpleValue(Phi->getIncomingValue(oi), Val.getIndex()));
  } else if (auto EVI = dyn_cast<ExtractValueInst>(Val.getValue())) {
    // extractvalue: add the appropriate struct element of the input
    ConnectedVals->push_back(SimpleValue(EVI->getOperand(0),
            Val.getIndex() + IndexFlattener::flatten(
              cast<StructType>(EVI->getOperand(0)->getType()),
              EVI->getIndices())));
  } else if (auto IVI = dyn_cast<InsertValueInst>(Val.getValue())) {
    // insertvalue: add the appropriate struct element in either the
    // aggregate input or the value to insert input
    unsigned InsertedIndex = Val.getIndex() - IndexFlattener::flatten(
        cast<StructType>(IVI->getType()), IVI->getIndices());
    unsigned NumElements = IndexFlattener::getNumElements(
        IVI->getOperand(1)->getType());
    SimpleValue SV;
    if (InsertedIndex < NumElements)
      SV = SimpleValue(IVI->getOperand(1), InsertedIndex);
    else
      SV = SimpleValue(IVI->getOperand(0), Val.getIndex());
    ConnectedVals->push_back(SV);
  } else if (auto CI = dyn_cast<CallInst>(Val.getValue())) {
    switch (getIntrinsicID(CI)) {
      case Intrinsic::genx_simdcf_goto:
        // goto: invalid unless it is the EM/RM result of goto as applicable
        if (Val.getIndex() != (Cat == RegCategory::EM ? 0U : 1U))
          return false;
        // Add the corresponding input.
        ConnectedVals->push_back(CI->getOperand(Val.getIndex()));
        // If doing EM connections, add the corresponding join. This does
        // nothing if checkJoin has not yet run for the corresponding join,
        // since GotoJoinMap has not yet been set up for our goto. We tolerate
        // that situation; if the goto really has no linked join, that is
        // picked up later in checkGoto.
        if (Cat == RegCategory::EM)
          if (auto Join = GotoJoinMap[cast<CallInst>(Val.getValue())])
            ConnectedVals->push_back(
                SimpleValue(Join, 0/* struct idx of EM result */));
        break;
      case Intrinsic::genx_simdcf_join: {
        // join: invalid unless it is the EM result
        if (Val.getIndex() || Cat != RegCategory::EM)
          return false;
        // Add the corresponding input.
        ConnectedVals->push_back(CI->getOperand(Val.getIndex()));
        // Add the corresponding gotos. This does nothing if checkJoin has not
        // yet run for this join, since RMVals has not yet been set up for it.
        // That is OK, because adding the corresponding gotos here is required
        // only when we are called by removeBadEMVal to remove the join, so the
        // gotos get re-checked and found to be invalid.
        auto RMValsEntry = &RMVals[cast<CallInst>(Val.getValue())];
        for (auto i = RMValsEntry->begin(), e = RMValsEntry->end(); i != e; ++i)
          if (getIntrinsicID(i->getValue()) == Intrinsic::genx_simdcf_goto)
            ConnectedVals->push_back(
                SimpleValue(i->getValue(), 0/* struct idx of EM result */));
        break;
      }
      case Intrinsic::genx_constantpred:
        // constantpred: add the constant. Don't add any other uses of it,
        // because it might be commoned up with other RM webs.
        ConnectedVals->push_back(CI->getOperand(0));
        return true;
      case Intrinsic::not_intrinsic: {
        // Value returned from a call.
        if (Cat != RegCategory::EM)
          return false; // invalid for RM
        // Add the corresponding value at each return in the called function.
        auto CalledFunc = CI->getCalledFunction();
        for (auto fi = CalledFunc->begin(), fe = CalledFunc->end();
            fi != fe; ++fi)
          if (auto Ret = dyn_cast<ReturnInst>(fi->getTerminator()))
            ConnectedVals->push_back(
                SimpleValue(Ret->getOperand(0), Val.getIndex()));
        // Connected to some call arg. There is a problem here in that it might
        // find another predicate arg that is nothing to do with SIMD CF, and
        // thus stop SIMD CF being optimized. But passing a predicate in and
        // out of a function is rare outside of SIMD CF, so we do not worry
        // about that.
        auto ValTy = IndexFlattener::getElementType(
            Val.getType(), Val.getIndex());
        for (unsigned Idx = 0, End = CI->getNumArgOperands(); ; ++Idx) {
          if (Idx == End)
            return false; // no corresponding call arg found
          if (CI->getArgOperand(Idx)->getType() == ValTy) {
            ConnectedVals->push_back(SimpleValue(CI->getArgOperand(Idx), 0));
            break;
          }
        }
        break;
      }
      default:
        return false; // unexpected call as def
    }
  } else
    return false; // unexpected instruction as def
  // Check the uses.
  for (auto ui = Val.getValue()->use_begin(),
      ue = Val.getValue()->use_end(); ui != ue; ++ui) {
    auto User = cast<Instruction>(ui->getUser());
    if (auto Phi = dyn_cast<PHINode>(User)) {
      // Use in phi node. Add the phi result.
      ConnectedVals->push_back(SimpleValue(Phi, Val.getIndex()));
      continue;
    }
    if (auto EVI = dyn_cast<ExtractValueInst>(User)) {
      // Use in extractvalue.
      // If extracting the right index, add the result.
      unsigned StartIndex = IndexFlattener::flatten(
          cast<StructType>(EVI->getOperand(0)->getType()), EVI->getIndices());
      unsigned NumIndices = IndexFlattener::getNumElements(EVI->getType());
      unsigned ExtractedIndex = Val.getIndex() - StartIndex;
      if (ExtractedIndex < NumIndices)
        ConnectedVals->push_back(SimpleValue(EVI, ExtractedIndex));
      continue;
    }
    if (auto IVI = dyn_cast<InsertValueInst>(User)) {
      // Use in insertvalue. Could be either the aggregate input or the value
      // to insert.
      unsigned StartIndex = IndexFlattener::flatten(
          cast<StructType>(IVI->getType()), IVI->getIndices());
      unsigned NumIndices = IndexFlattener::getNumElements(
          IVI->getOperand(1)->getType());
      if (!ui->getOperandNo()) {
        // Use in insertvalue as the aggregate input. Add the corresponding
        // element in the result, as long as it is not overwritten by the
        // insertvalue.
        if (Val.getIndex() - StartIndex >= NumIndices)
          ConnectedVals->push_back(SimpleValue(IVI, Val.getIndex()));
      } else {
        // Use in insertvalue as the value to insert. Add the corresponding
        // element in the result.
        ConnectedVals->push_back(SimpleValue(IVI, StartIndex + Val.getIndex()));
      }
      continue;
    }
    if (isa<ReturnInst>(User)) {
      // Use in a return.
      if (Cat != RegCategory::EM)
        return false; // invalid for RM
      // Connected to some function arg. There is a problem here in that it might
      // find another predicate arg that is nothing to do with SIMD CF, and
      // thus stop SIMD CF being optimized. But passing a predicate in and
      // out of a function is rare outside of SIMD CF, so we do not worry
      // about that.
      auto ValTy = IndexFlattener::getElementType(
          Val.getType(), Val.getIndex());
      auto F = User->getParent()->getParent();
      for (auto ai = F->arg_begin(), ae = F->arg_end(); ; ++ai) {
        if (ai == ae)
          return false; // no arg of the right type found
        auto Arg = &*ai;
        if (Arg->getType() == ValTy) {
          ConnectedVals->push_back(SimpleValue(Arg, 0));
          break;
        }
      }
      if (IncludeOptional) {
        // With IncludeOptional, also add the values connected by being the
        // return value at each call site.
        for (auto ui = F->use_begin(), ue = F->use_end(); ui != ue; ++ui)
          if (auto CI = dyn_cast<CallInst>(ui->getUser()))
            ConnectedVals->push_back(SimpleValue(CI, Val.getIndex()));
      }
      continue;
    }
    if (isa<SelectInst>(User)) {
      // A use in a select is allowed only for EM used as the condition.
      if (Cat != RegCategory::EM || ui->getOperandNo() != 0)
        return false;
      continue;
    }
    if (auto SVI = dyn_cast<ShuffleVectorInst>(User)) {
      int SliceIndex = ShuffleVectorAnalyzer(SVI).getAsSlice();
      if (SliceIndex < 0)
        return false;
      // This is a shufflevector that is a slice, so will be lowered to
      // rdpredregion. (We only see this in the early pass; GenXLowering has
      // turned it into rdpredregion by the late pass.) Check that all its uses
      // are select or wrregion.
      if (!checkAllUsesAreSelectOrWrRegion(SVI))
        return false;
      return true;
    }
    if (auto CI = dyn_cast<CallInst>(User)) {
      switch (getIntrinsicID(CI)) {
        case Intrinsic::genx_simdcf_goto:
          // use in goto: valid only if arg 0 (EM) or 1 (RM)
          if (ui->getOperandNo() != (Cat == RegCategory::EM ? 0U : 1U))
            return false;
          // Add corresponding result.
          ConnectedVals->push_back(SimpleValue(CI, ui->getOperandNo()));
          break;
        case Intrinsic::genx_simdcf_join:
          // use in join: valid only if arg 0 (EM) or 1 (RM)
          if (ui->getOperandNo() != (Cat == RegCategory::EM ? 0U : 1U))
            return false;
          // If EM, add corresponding result.
          if (Cat == RegCategory::EM)
            ConnectedVals->push_back(SimpleValue(CI, 0));
          else if (OkJoin && OkJoin != CI) {
            // RM value used in a join other than OkJoin. That is illegal, as we
            // can only have one join per RM web.
            DEBUG(dbgs() << "getConnectedVals: found illegal join: " << CI->getName() << "\n");
            return false;
          }
          break;
        case Intrinsic::genx_wrregionf:
        case Intrinsic::genx_wrregioni:
          break; // Use as wrregion predicate is allowed.
        case Intrinsic::genx_rdpredregion:
          // We only see rdpredregion in the late pass; in the early pass it is
          // still a shufflevector.  Check that all its uses are select or
          // wrregion.
          if (!checkAllUsesAreSelectOrWrRegion(CI))
            return false;
          break;
        case Intrinsic::genx_wrpredpredregion:
          // Use in wrpredpredregion allowed as the last arg.
          if (ui->getOperandNo() + 1 != CI->getNumArgOperands())
            return false;
          break;
        default:
          // Allowed as an predicate in a non-ALU intrinsic.
          if (CI->getCalledFunction()->doesNotAccessMemory())
            return false;
          break;
        case Intrinsic::not_intrinsic: {
          // Use in subroutine call. Add the corresponding function arg.
          Function *CalledFunc = CI->getCalledFunction();
          auto ai = CalledFunc->arg_begin();
          for (unsigned Count = ui->getOperandNo(); Count; --Count, ++ai)
            ;
          Argument *Arg = &*ai;
          ConnectedVals->push_back(SimpleValue(Arg, Val.getIndex()));
          // Connected to some return value from the call. There is a problem
          // here in that it might find another predicate return value that is
          // nothing to do with SIMD CF, and thus stop SIMD CF being optimized.
          // But passing a predicate in and out of a function is rare outside
          // of SIMD CF, so we do not worry about that.
          unsigned RetIdx = 0;
          auto ValTy = IndexFlattener::getElementType(
              Val.getValue()->getType(), Val.getIndex());
          if (auto ST = dyn_cast<StructType>(CI->getType())) {
            for (unsigned End = IndexFlattener::getNumElements(ST); ; ++RetIdx) {
              if (RetIdx == End)
                return false; // no predicate ret value found
              if (IndexFlattener::getElementType(ST, RetIdx) == ValTy) {
                ConnectedVals->push_back(SimpleValue(CI, RetIdx));
                break;
              }
            }
          } else if (CI->getType() != ValTy)
            return false; // no predicate ret value found
          else
            ConnectedVals->push_back(SimpleValue(CI, 0));
          break;
        }
      }
      continue;
    }
    return false; // invalid use
  }
  return true;
}

// check if this is an EM value or part of an EM value.
static bool isEM(Value *V) {
  if (auto SI = dyn_cast<ShuffleVectorInst>(V))
    return isEM(SI->getOperand(0)) || isEM(SI->getOperand(1));
  return GotoJoin::isEMValue(V);
}

// canonicalizeEM : canonicalize EM uses so that EM uses will not
// stop SIMD-CF conformance.
void GenXSimdCFConformance::canonicalizeEM() {
  using namespace PatternMatch;
  std::vector<Instruction *> DeadInstructions;

  for (auto &F : M->getFunctionList())
    for (auto &BB : F.getBasicBlockList()) {
      for (Instruction *Inst = BB.getTerminator(); Inst;) {
        // select(C0&C1, a, b) -> select(C0, select(C1, a, b), b)
        // select(C0|C1, a, b) -> select(C0, a, select(C1, a, b))
        Value *C0, *C1, *A, *B;
        if (match(Inst, m_Select(m_BinOp(m_Value(C0), m_Value(C1)), m_Value(A),
                                 m_Value(B)))) {
          bool C1IsEM = isEM(C1);
          if (C1IsEM || isEM(C0)) {
            Value *Cond = Inst->getOperand(0);
            if (Cond->getType()->isVectorTy()) {
              BinaryOperator *BO = cast<BinaryOperator>(Cond);
              IRBuilder<> Builder(BO);
              if (C1IsEM)
                std::swap(C0, C1);
              if (BO->getOpcode() == BinaryOperator::And) {
                Value *V = Builder.CreateSelect(C1, A, B);
                V = Builder.CreateSelect(C0, V, B);
                Inst->replaceAllUsesWith(V);
                DeadInstructions.push_back(Inst);
              } else if (BO->getOpcode() == BinaryOperator::Or) {
                Value *V = Builder.CreateSelect(C1, A, B);
                V = Builder.CreateSelect(C0, A, V);
                Inst->replaceAllUsesWith(V);
                DeadInstructions.push_back(Inst);
              }
            }
          }
        }

        Inst = (Inst == &BB.front()) ? nullptr : Inst->getPrevNode();
      }
    }

  for (Instruction *I : DeadInstructions)
    RecursivelyDeleteTriviallyDeadInstructions(I);
}

/***********************************************************************
 * checkEMInterference : check for EM values interfering with each other,
 *      lowering gotos/joins as necessary
 *
 * There is only one EM in the hardware, and we need to model that by ensuring
 * that our multiple EM values, including phi nodes, do not interfere with each
 * other. This is effectively a register allocator with only one register.
 */
void GenXSimdCFConformance::checkEMInterference()
{
  // Do an interference check, returning a list of defs that appear in the live
  // range of other values.
  SetVector<Value *> BadDefs;
  checkInterference(&EMVals, &BadDefs, nullptr);
  for (auto i = BadDefs.begin(), e = BadDefs.end(); i != e; ++i)
    removeBadEMVal(*i);
}

/***********************************************************************
 * checkInterference : check for a list of values interfering with each other
 *
 * Enter:   Vals = values to check (not constants)
 *          BadDefs = SetVector in which to store any def that is found in the
 *                    live range of another def
 *          ConstStop = instruction to treat as the def point of a constantpred,
 *                      nullptr to treat the start of the function as the def
 *                      point
 *
 * This code finds interference by scanning back from uses, finding other defs,
 * relying on the dominance property of SSA. Having found that two EM values A
 * and B interfere due to the def of A appearing in the live range of B, we
 * could choose either one to lower its goto and join. In fact we choose A (the
 * found def), as that tends to lower inner SIMD CF, giving a chance for the
 * outer SIMD CF to become legal.
 *
 * Because GenXSimdCFConformance runs before live ranges are determined, so
 * that it can modify code as it wants, we cannot use the normal interference
 * testing code in GenXLiveness.
 *
 * The idea of ConstStop is different depending on whether we are testing
 * interference of all EM values, or all RM values for a particular join:
 *
 * * For interference between all EM values, any constant (input to
 *   constantpred intrinsic) must be all ones, which is checked elsewhere. It
 *   represents the state of the execution mask at the start of the function,
 *   therefore we need to pretend that the constantpred's live range extends
 *   back to the start of the function.  This is done by the caller setting
 *   ConstStop to 0.
 *
 * * For interference between all RM values for one particular join, any
 *   constant must be all zeros, which is checked elsewhere. It represents the
 *   state of that join's resume mask on entry to the function, and just after
 *   executing the join. Therefore we need to pretend that the constantpred's
 *   live range extends back to those two places. This is done by the caller
 *   setting ConstStop to the join instruction.
 */
void GenXSimdCFConformance::checkInterference(SetVector<SimpleValue> *Vals,
    SetVector<Value *> *BadDefs, Instruction *ConstStop)
{
  // Scan the live range of each value, looking for a def of another value.
  // Finding such a def indicates interference.
  for (auto evi = Vals->begin(), eve = Vals->end(); evi != eve; ++evi) {
    Value *EMVal = evi->getValue();
    bool IsConstantPred = getIntrinsicID(EMVal) == Intrinsic::genx_constantpred;
    // Set of blocks where we know the value is live out.
    SmallSet<BasicBlock *, 8> LiveOut;
    // Start from each use and scan backwards.
    for (auto ui = EMVal->use_begin(), ue = EMVal->use_end(); ui != ue; ++ui) {
      auto User = cast<Instruction>(ui->getUser());
      if (auto EVI = dyn_cast<ExtractValueInst>(User)) {
        // Ignore a use that is an extractvalue not involving the right struct
        // index.
        unsigned StartIndex = IndexFlattener::flatten(
            cast<StructType>(EVI->getOperand(0)->getType()), EVI->getIndices());
        unsigned NumIndices = IndexFlattener::getNumElements(EVI->getType());
        if (evi->getIndex() - StartIndex >= NumIndices)
          continue;
      }
      BasicBlock *PhiPred = nullptr;
      if (auto Phi = dyn_cast<PHINode>(User))
        PhiPred = Phi->getIncomingBlock(ui->getOperandNo());
      auto Inst = User;
      SmallVector<BasicBlock *, 4> PendingBBStack;
      for (;;) {
        if (!Inst) {
          // Go on to the next pending predecessor.
          if (PendingBBStack.empty())
            break;
          Inst = PendingBBStack.back()->getTerminator();
          PendingBBStack.pop_back();
        }
        if (&Inst->getParent()->front() == Inst) {
          // Reached the start of the block. Make all unprocessed predecessors
          // pending. Except if the use is in a phi node and this is the first
          // time we reach the start of a block: in that case, mark only the
          // corresponding phi block is pending.
          if (PhiPred) {
            if (LiveOut.insert(PhiPred).second)
              PendingBBStack.push_back(PhiPred);
            PhiPred = nullptr;
          } else {
            for (auto bui = Inst->getParent()->use_begin(),
                bue = Inst->getParent()->use_end(); bui != bue; ++bui) {
              auto Pred = cast<TerminatorInst>(bui->getUser())->getParent();
              if (LiveOut.insert(Pred).second)
                PendingBBStack.push_back(Pred);
            }
          }
          Inst = nullptr;
          continue;
        }
        // Go back to the previous instruction. (This happens even when
        // starting at the end of a new block, thus skipping scanning the uses
        // of the terminator, but that's OK because the terminator never uses
        // our EM or RM values.)
        Inst = Inst->getPrevNode();
        if (Inst == EMVal && !IsConstantPred) {
          // Reached the def of the value. Stop scanning, unless the def is
          // constantpred, in which case we pretend it was live from the
          // ConstStop.
          Inst = nullptr;
          continue;
        }
        if (Inst == ConstStop && IsConstantPred) {
          // For a constantpred value, we have reached the point that we want
          // to treat as its definition point.  Stop scanning.
          Inst = nullptr;
          continue;
        }
        // Check if this is the def of some other EM value.
        if (auto VT = dyn_cast<VectorType>(Inst->getType()))
          if (VT->getElementType()->isIntegerTy(1))
            if (Vals->count(Inst)) {
              // It is the def of some other EM value. Mark that one as
              // interfering. However do not mark it if both values are
              // constantpred, since we pretend all of those are defined at the
              // start of the function.
              if (!IsConstantPred
                  || getIntrinsicID(Inst) != Intrinsic::genx_constantpred) {
                DEBUG(dbgs() << "GenXSimdCFConformance::checkInterference: def of " << Inst->getName() << " found in live range of " << EMVal->getName() << "\n");
                BadDefs->insert(Inst);
              }
            }
        // Check if this instruction uses our value. If so, we can stop
        // scanning.
        for (unsigned oi = 0, oe = Inst->getNumOperands(); oi != oe; ++oi)
          if (Inst->getOperand(oi) == EMVal) {
            Inst = nullptr;
            break;
          }
      }
    }
  }
}

/***********************************************************************
 * insertCond : insert a vector of i1 value into the start of another one
 *
 * Enter:   OldVal = value to insert into
 *          NewVal = value to insert, at index 0
 *          Name = name for any new instruction
 *          InsertBefore = where to insert any new instruction
 *          DL = debug loc to give any new instruction
 *
 * Return:  value, possibly the same as the input value
 */
Value *GenXSimdCFConformance::insertCond(Value *OldVal, Value *NewVal,
    const Twine &Name, Instruction *InsertBefore, DebugLoc DL)
{
  unsigned OldWidth = OldVal->getType()->getVectorNumElements();
  unsigned NewWidth = NewVal->getType()->getVectorNumElements();
  if (OldWidth == NewWidth)
    return NewVal;
  // Do the insert with shufflevector. We need two shufflevectors, one to extend
  // NewVal to OldVal's width, and one to combine them.
  // GenXLowering decides whether this is suitable to lower to wrpredregion, or
  // needs to be lowered to something less efficient.
  SmallVector<Constant *, 32> Indices;
  Type *I32Ty = Type::getInt32Ty(InsertBefore->getContext());
  unsigned i;
  for (i = 0; i != NewWidth; ++i)
    Indices.push_back(ConstantInt::get(I32Ty, i));
  auto UndefIndex = UndefValue::get(I32Ty);
  for (; i != OldWidth; ++i)
    Indices.push_back(UndefIndex);
  auto SV1 = new ShuffleVectorInst(NewVal, UndefValue::get(NewVal->getType()),
      ConstantVector::get(Indices), NewVal->getName() + ".extend", InsertBefore);
  SV1->setDebugLoc(DL);
  if (isa<UndefValue>(OldVal))
    return SV1;
  Indices.clear();
  for (i = 0; i != NewWidth; ++i)
    Indices.push_back(ConstantInt::get(I32Ty, i + OldWidth));
  for (; i != OldWidth; ++i)
    Indices.push_back(ConstantInt::get(I32Ty, i));
  auto SV2 = new ShuffleVectorInst(OldVal, SV1, ConstantVector::get(Indices),
      Name, InsertBefore);
  SV2->setDebugLoc(DL);
  return SV2;
}

/***********************************************************************
 * truncateCond : truncate a vector of i1 value
 *
 * Enter:   In = input value
 *          Ty = type to truncate to
 *          Name = name for any new instruction
 *          InsertBefore = where to insert any new instruction
 *          DL = debug loc to give any new instruction
 *
 * Return:  value, possibly the same as the input value
 */
Value *GenXSimdCFConformance::truncateCond(Value *In, Type *Ty,
    const Twine &Name, Instruction *InsertBefore, DebugLoc DL)
{
  unsigned InWidth = In->getType()->getVectorNumElements();
  unsigned TruncWidth = Ty->getVectorNumElements();
  if (InWidth == TruncWidth)
    return In;
  // Do the truncate with shufflevector. GenXLowering lowers it to rdpredregion.
  SmallVector<Constant *, 32> Indices;
  Type *I32Ty = Type::getInt32Ty(InsertBefore->getContext());
  unsigned i;
  for (i = 0; i != TruncWidth; ++i)
    Indices.push_back(ConstantInt::get(I32Ty, i));
  auto SV = new ShuffleVectorInst(In, UndefValue::get(In->getType()),
      ConstantVector::get(Indices), Name, InsertBefore);
  SV->setDebugLoc(DL);
  return SV;
}

/***********************************************************************
 * lowerGoto : lower a llvm.genx.simdcf.goto
 *
 * This also outputs a warning that we failed to optimize a SIMD branch.
 * We always output it, rather than including it in the -rpass mechanism
 * to enable or disable the warning, as it is an unexpected situation that
 * we want our users to report.
 */
void GenXSimdCFConformance::lowerGoto(CallInst *Goto)
{
  DEBUG(dbgs() << "lowerGoto: " << *Goto << "\n");
  DebugLoc DL = Goto->getDebugLoc();
  if (EnableGenXGotoJoin)
    DiagnosticInfoSimdCF::emit(Goto, "failed to optimize SIMD branch", DS_Warning);
  Value *Results[3];
  auto EM = Goto->getOperand(0);
  auto Cond = Goto->getOperand(2);
  // EM is always 32 bit. Extract SubEM, of the same width as Cond, from it.
  auto OldSubEM = truncateCond(EM, Cond->getType(),
      EM->getName() + ".sub", Goto, DL);
  // Result 1: NewRM = OldRM | (SubEM & ~Cond)
  auto NotCond = BinaryOperator::Create(Instruction::Xor, Cond,
      Constant::getAllOnesValue(Cond->getType()),
      Goto->getName() + ".notcond", Goto);
  NotCond->setDebugLoc(DL);
  auto NotCondAndSubEM = BinaryOperator::Create(Instruction::And, NotCond,
      OldSubEM, Goto->getName() + ".disabling", Goto);
  NotCondAndSubEM->setDebugLoc(DL);
  Value *OldRM = Goto->getArgOperand(1);
  auto NewRM = BinaryOperator::Create(Instruction::Or, OldRM, NotCondAndSubEM,
      Goto->getName() + ".newRM", Goto);
  NewRM->setDebugLoc(DL);
  Results[1] = NewRM;
  // And SubEM with Cond.
  auto SubEM = BinaryOperator::Create(Instruction::And, OldSubEM, Cond,
      Goto->getName() + ".subEM", Goto);
  SubEM->setDebugLoc(DL);
  // Insert that back into EM. That is result 0.
  Results[0] = EM = insertCond(EM, SubEM, Goto->getName() + ".EM", Goto, DL);
  // Result 2: BranchCond = !any(SubEM)
  Function *AnyFunc = Intrinsic::getDeclaration(M, Intrinsic::genx_any,
      SubEM->getType());
  auto Any = CallInst::Create(AnyFunc, SubEM,
      SubEM->getName() + ".any", Goto);
  Any->setDebugLoc(DL);
  auto Not = BinaryOperator::Create(Instruction::Xor, Any,
      Constant::getAllOnesValue(Any->getType()),
      Any->getName() + ".not", Goto);
  Not->setDebugLoc(DL);
  Results[2] = Not;
  // Replace uses.
  replaceGotoJoinUses(Goto, Results);
  Goto->eraseFromParent();
  Modified = true;
}

/***********************************************************************
 * lowerJoin : lower a llvm.genx.simdcf.join
 */
void GenXSimdCFConformance::lowerJoin(CallInst *Join)
{
  DEBUG(dbgs() << "lowerJoin: " << *Join << "\n");
  DebugLoc DL = Join->getDebugLoc();
  Value *Results[2];
  auto EM = Join->getOperand(0);
  auto RM = Join->getOperand(1);
  // EM is always 32 bit. Extract SubEM, of the same width as RM, from it.
  auto OldSubEM = truncateCond(EM, RM->getType(), EM->getName() + ".sub",
      Join, DL);
  // Or it with RM.
  auto SubEM = BinaryOperator::Create(Instruction::Or, OldSubEM, RM,
      Join->getName() + ".subEM", Join);
  SubEM->setDebugLoc(DL);
  // Insert that back into EM. That is result 0.
  Results[0] = EM = insertCond(EM, SubEM, Join->getName() + ".EM", Join, DL);
  // Result 1: BranchCond = !any(SubEM)
  Function *AnyFunc = Intrinsic::getDeclaration(M, Intrinsic::genx_any,
      SubEM->getType());
  auto Any = CallInst::Create(AnyFunc, SubEM,
      SubEM->getName() + ".any", Join);
  Any->setDebugLoc(DL);
  auto Not = BinaryOperator::Create(Instruction::Xor, Any,
      Constant::getAllOnesValue(Any->getType()),
      Any->getName() + ".not", Join);
  Not->setDebugLoc(DL);
  Results[1] = Not;
  // Replace uses.
  replaceGotoJoinUses(Join, Results);
  Join->eraseFromParent();
  Modified = true;
}

/***********************************************************************
 * replaceGotoJoinUses : replace uses of goto/join
 *
 * The goto and join intrinsics have multiple return values in a struct.
 * This attempts to find the extractvalues and replace those directly.
 * It also spots where a value is unused.
 */
void GenXSimdCFConformance::replaceGotoJoinUses(CallInst *GotoJoin,
    ArrayRef<Value *> Vals)
{
  SmallVector<ExtractValueInst *, 4> Extracts;
  for (auto ui = GotoJoin->use_begin(), ue = GotoJoin->use_end();
      ui != ue; ++ui) {
    auto Extract = dyn_cast<ExtractValueInst>(ui->getUser());
    if (Extract)
      Extracts.push_back(Extract);
  }
  for (auto ei = Extracts.begin(), ee = Extracts.end(); ei != ee; ++ei) {
    auto Extract = *ei;
    unsigned Index = Extract->getIndices()[0];
    if (Index >= Vals.size())
      continue;
    Extract->replaceAllUsesWith(Vals[Index]);
    Extract->eraseFromParent();
  }
  if (!GotoJoin->use_empty()) {
    // There are still some uses of the original goto/join. We need to
    // aggregate the result values into a struct.
    Value *StructVal = UndefValue::get(GotoJoin->getType());
    Instruction *InsertBefore = GotoJoin->getNextNode();
    for (unsigned Index = 0,
        End = cast<StructType>(GotoJoin->getType())->getNumElements();
        Index != End; ++Index)
      StructVal = InsertValueInst::Create(StructVal, Vals[Index],
          Index, "", InsertBefore);
    GotoJoin->replaceAllUsesWith(StructVal);
  } else {
    // Remove code for unused value. This is particularly useful at an outer
    // join, where the !any(NewEM) is unused, so we don't need to compute it.
    for (unsigned vi = 0; vi != Vals.size(); ++vi) {
      Value *V = Vals[vi];
      while (V && V->use_empty()) {
        auto I = dyn_cast<Instruction>(V);
        if (I == nullptr)
          continue;
        unsigned NumOperands = I->getNumOperands();
        if (auto CI = dyn_cast<CallInst>(I))
          NumOperands = CI->getNumArgOperands();
        V = nullptr;
        if (NumOperands == 1)
          V = I->getOperand(0);
        I->eraseFromParent();
      }
    }
  }
}

/***********************************************************************
 * setCategories : set webs of EM and RM values to category EM or RM
 *
 * This also modifies EM uses as needed.
 */
void GenXLateSimdCFConformance::setCategories()
{
  // First the EM values.
  for (auto ei = EMVals.begin(); ei != EMVals.end(); /* empty */) {
    SimpleValue EMVal = *ei;
    ei++;
    // For this EM value, set its category and modify its uses.
    Liveness->getOrCreateLiveRange(EMVal)->setCategory(RegCategory::EM);
    if (!isa<StructType>(EMVal.getValue()->getType()))
      modifyEMUses(EMVal.getValue());
    switch (getIntrinsicID(EMVal.getValue())) {
      case Intrinsic::genx_simdcf_join: {
        // For a join, set the category of each RM value.
        auto RMValsEntry = &RMVals[cast<CallInst>(EMVal.getValue())];
        for (auto vi = RMValsEntry->begin(), ve = RMValsEntry->end(); vi != ve; ++vi) {
          SimpleValue RMVal = *vi;
          // For this RM value, set its category.
          Liveness->getOrCreateLiveRange(RMVal)->setCategory(RegCategory::RM);
        }
      }
      // Fall through...
      case Intrinsic::genx_simdcf_goto: {
        // See if this is a branching goto/join where the "true" successor is
        // an empty critical edge splitter block.
        auto CI = cast<CallInst>(EMVal.getValue());
        BasicBlock *BB = CI->getParent();
        if (GotoJoin::isBranchingGotoJoinBlock(BB) == CI) {
          BasicBlock *TrueSucc = BB->getTerminator()->getSuccessor(0);
          if (BasicBlock *TrueSuccSucc
              = getEmptyCriticalEdgeSplitterSuccessor(TrueSucc)) {
            for (auto i = TrueSucc->begin(); i != TrueSucc->end(); /*empty*/) {
              Instruction *Inst = &*i++;
              auto Phi = dyn_cast<PHINode>(Inst);
              if (!Phi)
                break;
              if (Phi->getNumIncomingValues() == 1) {
                Phi->replaceAllUsesWith(Phi->getIncomingValue(0));
                Liveness->eraseLiveRange(Phi);
                removeFromEMRMVals(Phi);
                Phi->eraseFromParent();
              }
            }
            // now BB should be truely empty
            assert(isa<TerminatorInst>(&TrueSucc->front()) &&
                   "BB is not empty for removal");
            // For a branching goto/join where the "true" successor is an empty
            // critical edge splitter block, remove the empty block, to ensure
            // that the "true" successor is a join label.
            // Adjust phi nodes in TrueSuccSucc.
            adjustPhiNodesForBlockRemoval(TrueSuccSucc, TrueSucc);
            // Replace the use (we know there is only the one).
            BB->getTerminator()->setSuccessor(0, TrueSuccSucc);
            // Erase the critical edge splitter block.
            TrueSucc->eraseFromParent();
            Modified = true;
          }
        }
        break;
      }
    }
  }
}

/***********************************************************************
 * modifyEMUses : modify EM uses as needed
 */
void GenXLateSimdCFConformance::modifyEMUses(Value *EM)
{
  DEBUG(dbgs() << "modifyEMUses: " << EM->getName() << "\n");
  // Gather the selects we need to modify, at the same time as handling other
  // uses of the EM values.
  SmallVector <SelectInst *, 4> Selects;
  SmallVector <Value *, 4> EMs;
  EMs.push_back(EM);
  for (unsigned ei = 0; ei != EMs.size(); ++ei) {
    EM = EMs[ei];
    // Scan EM's uses.
    for (auto ui = EM->use_begin(), ue = EM->use_end(); ui != ue; ++ui) {
      auto User = cast<Instruction>(ui->getUser());
      if (auto Sel = dyn_cast<SelectInst>(User)) {
        assert(!ui->getOperandNo());
        Selects.push_back(Sel);
      } else switch (getIntrinsicID(User)) {
        case Intrinsic::genx_rdpredregion:
          // An rdpredregion of the EM. Find its uses in select too.
          EMs.push_back(User);
          break;
#ifndef NDEBUG
        case Intrinsic::genx_simdcf_goto:
        case Intrinsic::genx_simdcf_join:
          break;
        case Intrinsic::genx_wrregioni:
        case Intrinsic::genx_wrregionf:
          assert(ui->getOperandNo() == Intrinsic::GenXRegion::PredicateOperandNum);
          break;
        case Intrinsic::genx_wrpredpredregion:
          break;
        default:
          if (isa<ReturnInst>(User) || isa<InsertValueInst>(User)
              || isa<ExtractValueInst>(User))
            break;
          assert(!cast<CallInst>(User)->getCalledFunction()->doesNotAccessMemory()
              && "unexpected ALU intrinsic use of EM");
          break;
        case Intrinsic::not_intrinsic:
          assert((isa<PHINode>(User) || isa<InsertValueInst>(User)
                || isa<CallInst>(User) || isa<ReturnInst>(User))
              && "unexpected use of EM");
#endif
      }
    }
  }
  // Modify each select into a predicated wrregion.
  for (auto si = Selects.begin(), se = Selects.end(); si != se; ++si) {
    auto Sel = *si;
    Value *FalseVal = Sel->getFalseValue();
    if (auto C = dyn_cast<Constant>(FalseVal)) {
      if (!isa<UndefValue>(C)) {
        // The false value needs loading if it is a constant other than
        // undef.
        SmallVector<Instruction *, 4> AddedInstructions;
        FalseVal = ConstantLoader(C, nullptr, &AddedInstructions).loadBig(Sel);
        // ConstantLoader generated at least one instruction.  Ensure that
        // each one has debug loc and category.
        for (auto aii = AddedInstructions.begin(), aie = AddedInstructions.end();
            aii != aie; ++aii) {
          Instruction *I = *aii;
          I->setDebugLoc(Sel->getDebugLoc());
        }
      }
    }
    Region R(Sel);
    R.Mask = Sel->getCondition();
    assert(FalseVal);
    Value *Wr = R.createWrRegion(FalseVal, Sel->getTrueValue(),
          Sel->getName(), Sel, Sel->getDebugLoc());
    Sel->replaceAllUsesWith(Wr);
    Liveness->eraseLiveRange(Sel);
    Sel->eraseFromParent();
    Modified = true;
  }
}

/***********************************************************************
 * DiagnosticInfoSimdCF::emit : emit an error or warning
 */
void DiagnosticInfoSimdCF::emit(Instruction *Inst, StringRef Msg,
        DiagnosticSeverity Severity)
{
  DiagnosticInfoSimdCF Err(Severity, *Inst->getParent()->getParent(),
      Inst->getDebugLoc(), Msg);
  Inst->getContext().diagnose(Err);
}

